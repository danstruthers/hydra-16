ca65 V2.19 - Git 1d1dd42
Main file   : os_main.s
Current file: os_main.s

000000r 1               .debuginfo
000000r 1               
000000r 1               .include "defines.s"
000000r 2               .debuginfo
000000r 2               .macpack        cpu
000000r 3               ; CPU bitmask constants
000000r 3               CPU_ISET_NONE      = $0001
000000r 3               CPU_ISET_6502      = $0002
000000r 3               CPU_ISET_6502X     = $0004
000000r 3               CPU_ISET_6502DTV   = $0008
000000r 3               CPU_ISET_65SC02    = $0010
000000r 3               CPU_ISET_65C02     = $0020
000000r 3               CPU_ISET_65816     = $0040
000000r 3               CPU_ISET_SWEET16   = $0080
000000r 3               CPU_ISET_HUC6280   = $0100
000000r 3               ;CPU_ISET_M740     = $0200 not actually implemented
000000r 3               CPU_ISET_4510      = $0400
000000r 3               
000000r 3               ; CPU capabilities
000000r 3               CPU_NONE           = CPU_ISET_NONE
000000r 3               CPU_6502           = CPU_ISET_6502
000000r 3               CPU_6502X          = CPU_ISET_6502|CPU_ISET_6502X
000000r 3               CPU_6502DTV        = CPU_ISET_6502|CPU_ISET_6502DTV
000000r 3               CPU_65SC02         = CPU_ISET_6502|CPU_ISET_65SC02
000000r 3               CPU_65C02          = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65C02
000000r 3               CPU_65816          = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65816
000000r 3               CPU_SWEET16        = CPU_ISET_SWEET16
000000r 3               CPU_HUC6280        = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65C02|CPU_ISET_HUC6280
000000r 3               CPU_4510           = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65C02|CPU_ISET_4510
000000r 3               
000000r 2               
000000r 2               .import          WRITE_BYTE, WRITE_CHAR, WRITE_CRLF, WRITE_HEX, WRITE_HEX_MASK
000000r 2               IO_PORT_BASE    = $FF00
000000r 2               INPUT_BUFFER    = $7F00
000000r 2               
000000r 2               ; TIMING
000000r 2               CLK_CPS = 3579545   ; ~3.58 MHz
000000r 2               CLK_CPMS = (CLK_CPS/1000) + 1
000000r 2               
000000r 2               ROCKWELL_ACIA   = 1
000000r 2               
000000r 2               SR_19200        = $0F
000000r 2               SR_115200       = $00
000000r 2               
000000r 2               SR_SELECT       = SR_115200
000000r 2               
000000r 2               .if ROCKWELL_ACIA = 1
000000r 2               ZP_SERIAL_SEND_BUSY = $08
000000r 2               .else
000000r 2               SWT_19200_BASE  = 90
000000r 2               SWT_19200       = ((SWT_19200_BASE * CLK_CPMS) / 1000) + 1
000000r 2               SWT_115200      = SWT_19200 / 6
000000r 2               
000000r 2                   .if SR_SELECT = SR_19200
000000r 2               SWT_SELECT      = SWT_19200
000000r 2                   .else
000000r 2               SWT_SELECT      = SWT_115200
000000r 2                   .endif
000000r 2               .endif
000000r 2               
000000r 2               .struct IO_Port
000000r 2                   Bytes       .byte 16
000000r 2               .endstruct
000000r 2               
000000r 2               .struct IO_Port_10_Bytes
000000r 2                   Bytes       .byte 10
000000r 2               .endstruct
000000r 2               
000000r 2               .macro HString Str
000000r 2                   .byte .strlen(Str), Str
000000r 2               .endmacro
000000r 2               
000000r 2               ;.struct SerialInfo
000000r 2               ;    .byte   IOPort_IRQ
000000r 2               ;    .byte   Read_Ptr_L
000000r 2               ;    .byte   Read_Ptr_H
000000r 2               ;    .byte   Write_Ptr_L
000000r 2               ;    .byte   Write_Ptr_H
000000r 2               ;.endstruct
000000r 2               
000000r 2               ;.macro SERIAL_INFO port, irq, task, buff_addr
000000r 2               ;.endmacro
000000r 2               
000000r 2               ;.macro Serial_Buffer_Advance info
000000r 2               ;.endmacro
000000r 2               
000000r 2               .define IO_PORT_BYTE(port, byte) port + IO_Port::Bytes + byte
000000r 2               
000000r 2               VIA1            = IO_PORT_0
000000r 2               ACIA            = IO_PORT_1
000000r 2               YM_SOUND        = IO_PORT_4
000000r 2               
000000r 2               VIA_PORTB       = IO_PORT_BYTE VIA1, 0
000000r 2               VIA_PORTA       = IO_PORT_BYTE VIA1, 1
000000r 2               VIA_PORTA_NOHS  = IO_PORT_BYTE VIA1, $F
000000r 2               VIA_DDRB        = IO_PORT_BYTE VIA1, 2
000000r 2               VIA_DDRA        = IO_PORT_BYTE VIA1, 3
000000r 2               
000000r 2               VIA_T1C_L       = IO_PORT_BYTE VIA1, 4
000000r 2               VIA_T1C_H       = IO_PORT_BYTE VIA1, 5
000000r 2               VIA_T1L_L       = IO_PORT_BYTE VIA1, 6
000000r 2               VIA_T1L_H       = IO_PORT_BYTE VIA1, 7
000000r 2               
000000r 2               VIA_T2C_L       = IO_PORT_BYTE VIA1, 8
000000r 2               VIA_T2C_H       = IO_PORT_BYTE VIA1, 9
000000r 2               
000000r 2               VIA_SHIFT_REG   = IO_PORT_BYTE VIA1, $A
000000r 2               VIA_AUX_CTRL    = IO_PORT_BYTE VIA1, $B
000000r 2               VIA_PER_CTRL    = IO_PORT_BYTE VIA1, $C
000000r 2               VIA_INT_FLAGS   = IO_PORT_BYTE VIA1, $D
000000r 2               VIA_INT_ENABLE  = IO_PORT_BYTE VIA1, $E
000000r 2               
000000r 2               ACIA_DATA       = IO_PORT_BYTE ACIA, 0
000000r 2               ACIA_STATUS     = IO_PORT_BYTE ACIA, 1
000000r 2               ACIA_CMD        = IO_PORT_BYTE ACIA, 2
000000r 2               ACIA_CTRL       = IO_PORT_BYTE ACIA, 3
000000r 2               
000000r 2               ; IRQs, from highest priority (0) to lowest (15)
000000r 2               IRQ_NUMBER_HIGHEST_PRI = 0
000000r 2               IRQ_NUMBER_ONBOARD_VIA = 0         ; System timers, etc
000000r 2               IRQ_NUMBER_ONBOARD_SERIAL = 1      ; On-board serial
000000r 2               
000000r 2               IRQ_NUMBER_SLOT_0_L = 2
000000r 2               IRQ_NUMBER_SLOT_0_H = 3
000000r 2               
000000r 2               IRQ_NUMBER_ONBOARD_SOUND = 4       ; YM-2151
000000r 2               
000000r 2               ; SLOT-assigned IRQs, low (higher-priority)
000000r 2               IRQ_NUMBER_SLOT_1_L = 5
000000r 2               IRQ_NUMBER_SLOT_2_L = 6
000000r 2               IRQ_NUMBER_SLOT_3_L = 7
000000r 2               IRQ_NUMBER_SLOT_4_L = 8
000000r 2               IRQ_NUMBER_SLOT_5_L = 9
000000r 2               
000000r 2               ; SLOT-assigned IRQs, high (lower-priority)
000000r 2               IRQ_NUMBER_SLOT_1_H = 10
000000r 2               IRQ_NUMBER_SLOT_2_H = 11
000000r 2               IRQ_NUMBER_SLOT_3_H = 12
000000r 2               IRQ_NUMBER_SLOT_4_H = 13
000000r 2               IRQ_NUMBER_SLOT_5_H = 14
000000r 2               
000000r 2               IRQ_NUMBER_15 = 15                  ; not assigned to any hardware or slot
000000r 2               IRQ_NUMBER_LOWEST_PRI = 15
000000r 2               IRQ_NUMBER_SW = 15
000000r 2               
000000r 2               YM_REG          = IO_PORT_BYTE YM_SOUND, 0
000000r 2               YM_DATA         = IO_PORT_BYTE YM_SOUND, 1
000000r 2               
000000r 2               ACIA_STATUS_BIT_IRQ  =  $80
000000r 2               ACIA_STATUS_BIT_DSRB =  $40
000000r 2               ACIA_STATUS_BIT_DCD =   $20
000000r 2               ACIA_STATUS_BIT_TDRE =  $10         ; for WDC 65C51, this is never 1 during transmission
000000r 2               ACIA_STATUS_BIT_RDRF =  $08
000000r 2               ACIA_STATUS_BIT_OVR =   $04
000000r 2               ACIA_STATUS_BIT_FE =    $02
000000r 2               ACIA_STATUS_BIT_PE =    $01
000000r 2               
000000r 2               ACIA_CMD_BIT_PME =      $20
000000r 2               ACIA_CMD_BIT_RECHO =    $10
000000r 2               ACIA_CMD_BIT_TLID =     $08
000000r 2               ACIA_CMD_BIT_TLIE =     $04
000000r 2               ACIA_CMD_BIT_RID  =     $02
000000r 2               ACIA_CMD_BIT_RIE  =     $00
000000r 2               ACIA_CMD_BIT_DTRL =     $01
000000r 2               
000000r 2               ; SPI Defines
000000r 2               
000000r 2               IOR_SPI_DATA        = VIA_PORTB
000000r 2               IOR_SPI_DDR         = VIA_DDRB
000000r 2               
000000r 2               ; SPI DATA BITS
000000r 2               SPI_BIT_CLK     = 1     ; bit 0, so INC/DEC cycle the clock
000000r 2               SPI_BIT_CSB     = 2     ; bit 1
000000r 2               SPI_BIT_MOSI    = 4     ; bit 2
000000r 2               SPI_BIT_CS_1    = 8     ; bit 3
000000r 2               SPI_BIT_CS_2    = $10   ; bit 4
000000r 2               SPI_BIT_CS_4    = $20   ; bit 5
000000r 2               SPI_BIT_CS_8    = $40   ; bit 6
000000r 2               SPI_BIT_MISO    = $80   ; bit 7, so BIT opcode stores MISO in N
000000r 2               
000000r 2               SPI_DEV_0       = 0
000000r 2               SPI_DEV_1       = SPI_BIT_CS_1
000000r 2               SPI_DEV_2       = SPI_BIT_CS_2
000000r 2               SPI_DEV_3       = SPI_BIT_CS_2 | SPI_BIT_CS_1
000000r 2               SPI_DEV_4       = SPI_BIT_CS_4
000000r 2               SPI_DEV_5       = SPI_BIT_CS_4 | SPI_BIT_CS_1
000000r 2               SPI_DEV_6       = SPI_BIT_CS_4 | SPI_BIT_CS_2
000000r 2               SPI_DEV_7       = SPI_BIT_CS_4 | SPI_BIT_CS_2 | SPI_BIT_CS_1
000000r 2               
000000r 2               SPI_DEV_8       = SPI_BIT_CS_8 | SPI_DEV_0
000000r 2               SPI_DEV_9       = SPI_BIT_CS_8 | SPI_DEV_1
000000r 2               SPI_DEV_A       = SPI_BIT_CS_8 | SPI_DEV_2
000000r 2               SPI_DEV_B       = SPI_BIT_CS_8 | SPI_DEV_3
000000r 2               SPI_DEV_C       = SPI_BIT_CS_8 | SPI_DEV_4
000000r 2               SPI_DEV_D       = SPI_BIT_CS_8 | SPI_DEV_5
000000r 2               SPI_DEV_E       = SPI_BIT_CS_8 | SPI_DEV_6
000000r 2               SPI_DEV_F       = SPI_BIT_CS_8 | SPI_DEV_7
000000r 2               
000000r 2               SPI_DDR_BITS    = SPI_BIT_CLK | SPI_BIT_CSB | SPI_BIT_MOSI | SPI_DEV_F
000000r 2               
000000r 2               SPI_INIT_DELAY_CYCLES = 80
000000r 2               
000000r 2               ; max task idle
000000r 2               MAX_TASK_NUMBER = $0F           ; 16 tasks, numbered 0-F
000000r 2               NUM_RAM_MODULES = 15            ;
000000r 2               NUM_BANKS_PER_MODULE = 16
000000r 2               NUM_RAM_BANKS   = NUM_RAM_MODULES * NUM_BANKS_PER_MODULE
000000r 2               
000000r 2               T_REGISTER = $FFF0 ; IO_PORT_BYTE IO_PORT_F, 0
000000r 2               U_REGISTER = $FFF1 ; IO_PORT_BYTE IO_PORT_F, 1
000000r 2               V_REGISTER = $FFF2 ; IO_PORT_BYTE IO_PORT_F, 2
000000r 2               W_REGISTER = $FFF3 ; IO_PORT_BYTE IO_PORT_F, 3
000000r 2               
000000r 2               ; ERROR CODES
000000r 2               ERR_NO_TASKS_AVAILABLE = $F1
000000r 2               
000000r 2               ; Task switcher interrupt timer (one interrupt per 5ms or so, with 64 cycles for INT Handler overhead)
000000r 2               TIMER_TASK_INT_H = 69
000000r 2               TIMER_TASK_INT_L = 169
000000r 2               
000000r 2               ; ASCII CODES
000000r 2               ASCII_BACKSPACE = $08
000000r 2               ASCII_LF        = $0A
000000r 2               ASCII_CR        = $0D
000000r 2               ASCII_ESC       = $1B
000000r 2               ASCII_SPACE     = ' '
000000r 2               ASCII_BANG      = '!'
000000r 2               ASCII_DQUOTE    = '"'
000000r 2               ASCII_HASH      = '#'
000000r 2               ASCII_DOLLAR    = '$'
000000r 2               ASCII_PERCENT   = '%'
000000r 2               ASCII_CARET     = '^'
000000r 2               ASCII_AMP       = '&'
000000r 2               ASCII_SQOUTE    = '''
000000r 2               ASCII_LPAREN    = '('
000000r 2               ASCII_RPAREN    = ')'
000000r 2               ASCII_STAR      = '*'
000000r 2               ASCII_PLUS      = '+'
000000r 2               ASCII_COMMA     = ','
000000r 2               ASCII_MINUS     = '-'
000000r 2               ASCII_DASH      = ASCII_MINUS
000000r 2               ASCII_HYPHEN    = ASCII_MINUS
000000r 2               ASCII_PERIOD    = '.'
000000r 2               ASCII_SLASH     = '/'
000000r 2               ASCII_0         = '0'
000000r 2               ASCII_1         = '1'
000000r 2               ASCII_2         = '2'
000000r 2               ASCII_3         = '3'
000000r 2               ASCII_4         = '4'
000000r 2               ASCII_5         = '5'
000000r 2               ASCII_6         = '6'
000000r 2               ASCII_7         = '7'
000000r 2               ASCII_8         = '8'
000000r 2               ASCII_9         = '9'
000000r 2               ASCII_COLON     = ':'
000000r 2               ASCII_SEMI      = ':'
000000r 2               ASCII_LT        = '<'
000000r 2               ASCII_EQ        = '='
000000r 2               ASCII_GT        = '>'
000000r 2               ASCII_QUESTION  = '?'
000000r 2               ASCII_A         = 'A'
000000r 2               ASCII_J         = 'J'
000000r 2               ASCII_R         = 'R'
000000r 2               ASCII_S         = 'S'
000000r 2               ASCII_T         = 'T'
000000r 2               ASCII_U         = 'U'
000000r 2               ASCII_V         = 'V'
000000r 2               ASCII_W         = 'W'
000000r 2               ASCII_X         = 'X'
000000r 2               ASCII_Y         = 'Y'
000000r 2               ASCII_Z         = 'Z'
000000r 2               ASCII_f         = 'f'
000000r 2               ASCII_LBRACKET  = '['
000000r 2               ASCII_BACKSLASH = '\'
000000r 2               ASCII_RBRACKET  = ']'
000000r 2               ASCII_LBRACE    = '{'
000000r 2               ASCII_RBRACE    = '}'
000000r 2               
000000r 2               ASCII_LETTER_OFFSET = ASCII_A-ASCII_0-10
000000r 2               
000000r 2               ; write a byte in A to the IO PORT
000000r 2               .macro IO_PORT_WRITE    port, byte, imm
000000r 2               .ifnblank       imm
000000r 2                               lda     #imm
000000r 2               .endif
000000r 2               .ifblank        byte
000000r 2                               sta     port
000000r 2               .else
000000r 2                               sta     IO_PORT_BYTE port, byte
000000r 2               .endif
000000r 2               .endmacro
000000r 2               
000000r 2               ; read a byte into A from the IO PORT/Byte (PORT_N | BYTE_M)
000000r 2               .macro IO_PORT_READ     port, byte
000000r 2               .ifblank        byte
000000r 2                               lda     port
000000r 2               .else
000000r 2                               lda     IO_PORT_BYTE port, byte
000000r 2               .endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_AX
000000r 2                               pha
000000r 2                               phx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_XA
000000r 2                               plx
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_AY
000000r 2                               pha
000000r 2                               phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_YA
000000r 2                               ply
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_XY
000000r 2                               phx
000000r 2                               phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_YX
000000r 2                               ply
000000r 2                               plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_AXY
000000r 2                               pha
000000r 2                               phx
000000r 2                               phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_YXA
000000r 2                               ply
000000r 2                               plx
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               ; convenience macros
000000r 2               
000000r 2               ; MOV
000000r 2               ; Modifies: A
000000r 2               .macro MOV              addr1, addr2
000000r 2                               lda     addr1
000000r 2                               sta     addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVA             addr1, addr2
000000r 2                               MOV     addr1, addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVX             addr1, addr2
000000r 2                               ldx     addr1
000000r 2                               stx     addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVY             addr1, addr2
000000r 2                               ldy     addr1
000000r 2                               sty     addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOV16            addr1, addr2
000000r 2                               lda     addr1
000000r 2                               sta     addr2
000000r 2                               lda     addr1+1
000000r 2                               sta     addr2+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVA16           addr1, addr2
000000r 2                               MOV16   addr1, addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVX16           addr1, addr2
000000r 2                               ldx     addr1
000000r 2                               stx     addr2
000000r 2                               ldx     addr1+1
000000r 2                               stx     addr2+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVY16           addr1, addr2
000000r 2                               ldy     addr1
000000r 2                               sty     addr2
000000r 2                               ldy     addr1+1
000000r 2                               sty     addr2+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVAX            addr1, addr2
000000r 2                               lda     addr1,x
000000r 2                               sta     addr2,x
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVAY            addr1, addr2
000000r 2                               lda     addr1,y
000000r 2                               sta     addr2,y
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVAY16          addr1, addr2
000000r 2                               lda     addr1,y
000000r 2                               sta     addr2,y
000000r 2                               lda     addr1+1,y
000000r 2                               sta     addr2+1,y
000000r 2               .endmacro
000000r 2               
000000r 2               ; X: # of bytes to move
000000r 2               ; Clobbers A, X
000000r 2               .macro BLKMOVX          addr1, addr2
000000r 2               @:
000000r 2                               dex
000000r 2                               lda     addr1,x
000000r 2                               sta     addr2,x
000000r 2                               bne     @-
000000r 2               .endmacro
000000r 2               
000000r 2               ; Y: # of bytes to move
000000r 2               ; Clobbers A, Y
000000r 2               .macro BLKMOVY          addr1, addr2
000000r 2               @:
000000r 2                               dey
000000r 2                               lda     addr1,y
000000r 2                               sta     addr2,y
000000r 2                               bne     @-
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro  INC16           addr
000000r 2                               inc     addr
000000r 2                               bne     @+
000000r 2                               inc     addr+1
000000r 2                               bra     @++
000000r 2               @:
000000r 2                               lda     addr+1
000000r 2               @:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  INC32           addr
000000r 2                               inc     addr
000000r 2                               bne     @+
000000r 2                               inc     addr+1
000000r 2                               bne     @+
000000r 2                               INC16   addr+2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  DEC16           addr
000000r 2                               lda     addr
000000r 2                               bne     @+
000000r 2                               dec     addr
000000r 2                               dec     addr+1
000000r 2                               bra     @+++
000000r 2               @:
000000r 2                               dec     addr
000000r 2                               bne     @+      ; if Z not set, don't take Z from HOB
000000r 2                               lda     addr+1  ; sets Z and N from HOB
000000r 2                               bra     @++
000000r 2               @:
000000r 2                               lda     addr+1
000000r 2                               ora     #1      ; reset Z, if set, without affecting N
000000r 2               @:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  DEC32           addr
000000r 2                               lda     addr
000000r 2                               bne     @+++
000000r 2                               cmp     addr+1
000000r 2                               bne     @++
000000r 2                               cmp     addr+2
000000r 2                               bne     @+
000000r 2                               dec     addr+3
000000r 2               @:
000000r 2                               dec     addr+2
000000r 2               @:
000000r 2                               dec     addr+1
000000r 2               @:
000000r 2                               dec     addr
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 2               ; No-clobber (NC) macros to wrap another macro that overwrites one or more registers
000000r 2               .macro  NC_A            MAC, p1, p2
000000r 2                               pha
000000r 2                               MAC     p1, p2
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_X            MAC, p1, p2
000000r 2                               phx
000000r 2                               MAC     p1, p2
000000r 2                               plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_Y            MAC, p1, p2
000000r 2                               phy
000000r 2                               MAC     p1, p2
000000r 2                               ply
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_AX           MAC, p1, p2
000000r 2                               PUSH_AX
000000r 2                               MAC     p1, p2
000000r 2                               PULL_XA
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_AY           MAC, p1, p2
000000r 2                               PUSH_AY
000000r 2                               MAC     p1, p2
000000r 2                               PULL_YA
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_XY           MAC, p1, p2
000000r 2                               PUSH_XY
000000r 2                               MAC     p1, p2
000000r 2                               PULL_YX
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_AXY          MAC, p1, p2
000000r 2                               PUSH_AXY
000000r 2                               MAC     p1, p2
000000r 2                               PULL_YXA
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  DEC16_NC_A      addr
000000r 2                               NC_A    DEC16, addr
000000r 2               .endmacro
000000r 2               
000000r 2               .macro SWAP_AX
000000r 2                           pha
000000r 2                           txa
000000r 2                           plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro SWAP_AY
000000r 2                           pha
000000r 2                           tya
000000r 2                           ply
000000r 2               .endmacro
000000r 2               
000000r 2               ; SPI
000000r 2               .macro SPI_SEND_CMD b0, b1, b2, b3, b4, crc
000000r 2                               lda             #b0 | $40
000000r 2                               jsr             SPI_SEND
000000r 2                               lda             #b1
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               sta             ZP_TEMP_2
000000r 2                               lda             #b2
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               lda             #b3
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               lda             #b4
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2               .ifnblank       crc
000000r 2                               lda             #(crc << 1)+1
000000r 2               .else
000000r 2                               lda             #$FF
000000r 2               .endif
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               jsr             SPI_RECV
000000r 2                               sta             ZP_TEMP
000000r 2               .endmacro
000000r 2               
000000r 2               ; PRINT HELPERS
000000r 2               .define LOADA(arg)      lda     arg
000000r 2               
000000r 2               .macro  LDA_CORA    CharOrAddr
000000r 2               .ifnblank   CharOrAddr
000000r 2                       LOADA CharOrAddr
000000r 2               .endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CHAR      C1, C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .ifblank    C1
000000r 2                   .exitmacro
000000r 2               .else
000000r 2                               LDA_CORA        {C1}
000000r 2                               jsr             WRITE_CHAR
000000r 2               .endif
000000r 2                               PRINT_CHAR C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CHAR_JMP  C1, C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .ifblank    C1
000000r 2                   .exitmacro
000000r 2               .else
000000r 2                               LDA_CORA        {C1}
000000r 2                   .ifblank    C2
000000r 2                               jmp             WRITE_CHAR
000000r 2                               .exitmacro
000000r 2                   .else
000000r 2                               jsr             WRITE_CHAR
000000r 2                   .endif
000000r 2               .endif
000000r 2                               PRINT_CHAR_JMP C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_ESC_SEQ   C1, C2, C3, C4, C5, C6, C7, C8
000000r 2                               PRINT_CHAR #ASCII_ESC, C1, C2, C3, C4, C5, C6, C7, C8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_ESC_SEQ_JMP   C1, C2, C3, C4, C5, C6, C7, C8
000000r 2                               PRINT_CHAR_JMP #ASCII_ESC, C1, C2, C3, C4, C5, C6, C7, C8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_BYTE      CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jsr             WRITE_BYTE
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_BYTE_JMP  CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jmp             WRITE_BYTE
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_HEX       CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jsr             WRITE_HEX
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_HEX_MASK  CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jsr             WRITE_HEX_MASK
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CRLF
000000r 2                               jsr             WRITE_CRLF
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CRLF_JMP
000000r 2                               jmp             WRITE_CRLF
000000r 2               .endmacro
000000r 2               
000000r 2               ; JSR using JMP
000000r 2               .macro  JSRR    addrTo, addrFrom
000000r 2                               lda             #>addrFrom
000000r 2                               pha
000000r 2                               lda             #<addrFrom
000000r 2                               pha
000000r 2                               jmp             (addrTo)
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               .import IRQ_VECTOR_INIT, TASKS_INIT, SERIAL_INIT, SOUND_INIT, SOUND_TEST, SHELL_MAIN, CLEAR_SCR, PRINT_HEX, PRINT_CRLF, PRINT_CRLF_JMP, PRINT_CHAR, PRINT_BYTE, WRITE_CHAR
000000r 1               .import SPI_INIT_DELAY, SPI_SEND_CMD, ZP_TEMP, ZP_TEMP_2, ZP_A_SAVE, ZP_W_SAVE, SPI_RECV, SPI_TRANSCEIVE, SPI_SEND, IO_PORT_0, IO_PORT_1, IO_PORT_4, HYDRA_WELCOME
000000r 1               
000000r 1               .macro W_SAVE_AND_RESET
000000r 1                           sta     ZP_A_SAVE
000000r 1                           lda     W_REGISTER
000000r 1                           sta     ZP_W_SAVE
000000r 1                           stz     W_REGISTER
000000r 1                           lda     ZP_A_SAVE
000000r 1               .endmacro
000000r 1               
000000r 1               .macro W_RESTORE
000000r 1                           sta     ZP_A_SAVE
000000r 1                           lda     ZP_W_SAVE
000000r 1                           sta     W_REGISTER
000000r 1                           lda     ZP_A_SAVE
000000r 1               .endmacro
000000r 1               
000000r 1               .segment "BIOS_P0"
000000r 1               
000000r 1               .export RESET_ENTRY, SPI_TEST, SW_INT
000000r 1               
000000r 1               RESET_ENTRY:
000000r 1  8D rr rr AD              W_SAVE_AND_RESET                            ; Effectively a NOP, since we wouldn't be here if it was non-zero
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1                                                                       ;   but kept for consistency across all OS ROM pages
00000Fr 1  9C F0 FF                 stz     T_REGISTER                          ; Make sure task 0 is selected
000012r 1  64 00                    stz     $00                                 ; Init RAM Bank selector
000014r 1  64 01                    stz     $01                                 ; Init ROM Bank selector
000016r 1  A2 FF                    ldx     #$FF                                ; Init stack pointer
000018r 1  9A                       txs
000019r 1                           ; MOV     ZP_READ_PTR, ZP_WRITE_PTR                 ; remove when tasks_init is used
000019r 1               
000019r 1  20 rr rr                 jsr     IRQ_VECTOR_INIT
00001Cr 1  20 rr rr                 jsr     TASKS_INIT                          ; Must be called before SERIAL_INIT
00001Fr 1  20 rr rr                 jsr     SERIAL_INIT
000022r 1                           ;jsr     MMU_INIT
000022r 1                           ;jsr     SPI_INIT
000022r 1                           ;jsr     SPI_TEST
000022r 1  20 rr rr                 jsr     SOUND_INIT
000025r 1  20 rr rr                 jsr     SOUND_TEST
000028r 1  20 rr rr                 jsr     DO_WELCOME
00002Br 1  4C rr rr                 jmp     SHELL_MAIN
00002Er 1               
00002Er 1               DO_WELCOME:
00002Er 1  DA                       phx
00002Fr 1  20 rr rr                 jsr     CLEAR_SCR
000032r 1  A6 00                    ldx     0
000034r 1  BD rr rr                 lda     HYDRA_WELCOME, X
000037r 1  A8                       tay
000038r 1               @write_loop:
000038r 1  E8                       inx
000039r 1  BD rr rr                 lda     HYDRA_WELCOME, X
00003Cr 1  20 rr rr                 jsr     WRITE_CHAR
00003Fr 1  88                       dey
000040r 1  D0 F6                    bne     @write_loop
000042r 1  FA                       plx
000043r 1  20 rr rr                 PRINT_CRLF
000046r 1  A2 00                    ldx     #0
000048r 1               
000048r 1               @vector_loop:
000048r 1  8E F2 FF                 stx         V_REGISTER
00004Br 1  DA                       phx
00004Cr 1  AD F2 FF 20              PRINT_HEX   V_REGISTER
000050r 1  rr rr        
000052r 1  A9 08 20 rr              PRINT_CHAR  #ASCII_BACKSPACE
000056r 1  rr           
000057r 1  AD F2 FF                 lda         V_REGISTER
00005Ar 1  20 rr rr                 PRINT_HEX
00005Dr 1  A9 3A 20 rr              PRINT_CHAR  #ASCII_COLON
000061r 1  rr           
000062r 1  AD FF FF 20              PRINT_BYTE  $FFFF
000066r 1  rr rr        
000068r 1  AD FE FF 20              PRINT_BYTE  $FFFE
00006Cr 1  rr rr        
00006Er 1  A9 20 20 rr              PRINT_CHAR  #ASCII_SPACE
000072r 1  rr           
000073r 1  FA                       plx
000074r 1  E8                       inx
000075r 1  E0 10                    cpx         #$10
000077r 1  90 CF                    bcc         @vector_loop
000079r 1  4C rr rr                 PRINT_CRLF_JMP
00007Cr 1               
00007Cr 1               SPI_TEST:
00007Cr 1  A2 00                    ldx         #SPI_DEV_0
00007Er 1  20 rr rr                 jsr         SPI_INIT_DELAY
000081r 1  A9 40 20 rr              SPI_SEND_CMD 0,    0, 0, 0,   0, $4A        ; CMD0
000085r 1  rr A9 00 20  
000089r 1  rr rr 8D rr  
0000A8r 1  A9 48 20 rr              SPI_SEND_CMD 8,    0, 0, 1, $AA, $43        ; CMD8
0000ACr 1  rr A9 00 20  
0000B0r 1  rr rr 8D rr  
0000CFr 1               @loop:
0000CFr 1  A9 7A 20 rr              SPI_SEND_CMD 58,   0, 0, 0,   0             ; CMD58
0000D3r 1  rr A9 00 20  
0000D7r 1  rr rr 8D rr  
0000F6r 1  A9 69 20 rr              SPI_SEND_CMD 41, $40, 0, 0,   0             ; ACMD41
0000FAr 1  rr A9 40 20  
0000FEr 1  rr rr 8D rr  
00011Dr 1  D0 B0                    bne         @loop
00011Fr 1  60                       rts
000120r 1               
000120r 1               ; A: S/W interrupt number
000120r 1               SW_INT:
000120r 1  0A                       asl                                         ; move int# to V[4..7]
000121r 1  0A                       asl
000122r 1  0A                       asl
000123r 1  0A                       asl
000124r 1  09 0F                    ora         #$F
000126r 1  8D F2 FF                 sta         V_REGISTER
000129r 1  00                       brk                                         ; force an interrupt
00012Ar 1  60                       rts
00012Br 1               
00012Br 1               .segment "BIOS_P1"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P2"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P3"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P4"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P5"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P6"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P7"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P8"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_P9"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_PA"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_PB"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_PC"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_PD"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_PE"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               .segment "BIOS_PF"
000000r 1  8D rr rr AD              W_SAVE_AND_RESET
000004r 1  F3 FF 8D rr  
000008r 1  rr 9C F3 FF  
00000Fr 1               
00000Fr 1               
