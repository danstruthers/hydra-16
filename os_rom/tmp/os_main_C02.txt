ca65 V2.19 - Git 1d1dd42
Main file   : os_main.s
Current file: os_main.s

000000r 1               .debuginfo
000000r 1               
000000r 1               .include "defines.s"
000000r 2               .debuginfo
000000r 2               .macpack        cpu
000000r 3               ; CPU bitmask constants
000000r 3               CPU_ISET_NONE      = $0001
000000r 3               CPU_ISET_6502      = $0002
000000r 3               CPU_ISET_6502X     = $0004
000000r 3               CPU_ISET_6502DTV   = $0008
000000r 3               CPU_ISET_65SC02    = $0010
000000r 3               CPU_ISET_65C02     = $0020
000000r 3               CPU_ISET_65816     = $0040
000000r 3               CPU_ISET_SWEET16   = $0080
000000r 3               CPU_ISET_HUC6280   = $0100
000000r 3               ;CPU_ISET_M740     = $0200 not actually implemented
000000r 3               CPU_ISET_4510      = $0400
000000r 3               
000000r 3               ; CPU capabilities
000000r 3               CPU_NONE           = CPU_ISET_NONE
000000r 3               CPU_6502           = CPU_ISET_6502
000000r 3               CPU_6502X          = CPU_ISET_6502|CPU_ISET_6502X
000000r 3               CPU_6502DTV        = CPU_ISET_6502|CPU_ISET_6502DTV
000000r 3               CPU_65SC02         = CPU_ISET_6502|CPU_ISET_65SC02
000000r 3               CPU_65C02          = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65C02
000000r 3               CPU_65816          = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65816
000000r 3               CPU_SWEET16        = CPU_ISET_SWEET16
000000r 3               CPU_HUC6280        = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65C02|CPU_ISET_HUC6280
000000r 3               CPU_4510           = CPU_ISET_6502|CPU_ISET_65SC02|CPU_ISET_65C02|CPU_ISET_4510
000000r 3               
000000r 2               
000000r 2               ZP_VAR_START    = $10
000000r 2               
000000r 2               ZP_READ_PTR     = ZP_VAR_START
000000r 2               ZP_WRITE_PTR    = ZP_READ_PTR + 1
000000r 2               
000000r 2               ZP_TEMP         = ZP_WRITE_PTR + 1
000000r 2               ZP_TEMP_2       = ZP_TEMP + 1
000000r 2               
000000r 2               ZP_SPI_DATA_IN  = ZP_TEMP_2 + 1
000000r 2               ZP_SPI_DATA_OUT = ZP_SPI_DATA_IN + 1
000000r 2               
000000r 2               ZP_TEMP_VEC_L   = ZP_SPI_DATA_OUT + 1
000000r 2               ZP_TEMP_VEC_H   = ZP_TEMP_VEC_L + 1
000000r 2               
000000r 2               ZP_A_SAVE       = ZP_TEMP_VEC_H + 1
000000r 2               ZP_X_SAVE       = ZP_A_SAVE + 1
000000r 2               ZP_Y_SAVE       = ZP_X_SAVE + 1
000000r 2               ZP_T_SAVE       = ZP_Y_SAVE + 1
000000r 2               ZP_U_SAVE       = ZP_T_SAVE + 1
000000r 2               ZP_V_SAVE       = ZP_U_SAVE + 1
000000r 2               ZP_W_SAVE       = ZP_V_SAVE + 1
000000r 2               
000000r 2               ZP_LAST_USED    = ZP_W_SAVE
000000r 2               
000000r 2               IO_PORT_BASE    = $FF00
000000r 2               INPUT_BUFFER    = $7F00
000000r 2               
000000r 2               ; TIMING
000000r 2               CLK_CPS = 3579545   ; ~3.58 MHz
000000r 2               CLK_CPMS = (CLK_CPS/1000) + 1
000000r 2               
000000r 2               ROCKWELL_ACIA   = 1
000000r 2               
000000r 2               SR_19200        = $0F
000000r 2               SR_115200       = $00
000000r 2               
000000r 2               SR_SELECT       = SR_115200
000000r 2               
000000r 2               .if ROCKWELL_ACIA = 1
000000r 2               ZP_SERIAL_SEND_BUSY = $08
000000r 2               .else
000000r 2               SWT_19200_BASE  = 90
000000r 2               SWT_19200       = ((SWT_19200_BASE * CLK_CPMS) / 1000) + 1
000000r 2               SWT_115200      = SWT_19200 / 6
000000r 2               
000000r 2                   .if SR_SELECT = SR_19200
000000r 2               SWT_SELECT      = SWT_19200
000000r 2                   .else
000000r 2               SWT_SELECT      = SWT_115200
000000r 2                   .endif
000000r 2               .endif
000000r 2               
000000r 2               .struct IO_Port
000000r 2                   Bytes       .byte 16
000000r 2               .endstruct
000000r 2               
000000r 2               .struct IO_Port_10_Bytes
000000r 2                   Bytes       .byte 10
000000r 2               .endstruct
000000r 2               
000000r 2               .macro HString Str
000000r 2                   .byte .strlen(Str), Str
000000r 2               .endmacro
000000r 2               
000000r 2               ;.struct SerialInfo
000000r 2               ;    .byte   IOPort_IRQ
000000r 2               ;    .byte   Read_Ptr_L
000000r 2               ;    .byte   Read_Ptr_H
000000r 2               ;    .byte   Write_Ptr_L
000000r 2               ;    .byte   Write_Ptr_H
000000r 2               ;.endstruct
000000r 2               
000000r 2               ;.macro SERIAL_INFO port, irq, task, buff_addr
000000r 2               ;.endmacro
000000r 2               
000000r 2               ;.macro Serial_Buffer_Advance info
000000r 2               ;.endmacro
000000r 2               
000000r 2               .define IO_PORT_BYTE(port, byte) port + IO_Port::Bytes + byte
000000r 2               
000000r 2               VIA1            = IO_PORT_0
000000r 2               ACIA            = IO_PORT_1
000000r 2               YM_SOUND        = IO_PORT_4
000000r 2               
000000r 2               VIA_PORTB       = IO_PORT_BYTE VIA1, 0
000000r 2               VIA_PORTA       = IO_PORT_BYTE VIA1, 1
000000r 2               VIA_PORTA_NOHS  = IO_PORT_BYTE VIA1, $F
000000r 2               VIA_DDRB        = IO_PORT_BYTE VIA1, 2
000000r 2               VIA_DDRA        = IO_PORT_BYTE VIA1, 3
000000r 2               
000000r 2               VIA_T1C_L       = IO_PORT_BYTE VIA1, 4
000000r 2               VIA_T1C_H       = IO_PORT_BYTE VIA1, 5
000000r 2               VIA_T1L_L       = IO_PORT_BYTE VIA1, 6
000000r 2               VIA_T1L_H       = IO_PORT_BYTE VIA1, 7
000000r 2               
000000r 2               VIA_T2C_L       = IO_PORT_BYTE VIA1, 8
000000r 2               VIA_T2C_H       = IO_PORT_BYTE VIA1, 9
000000r 2               
000000r 2               VIA_SHIFT_REG   = IO_PORT_BYTE VIA1, $A
000000r 2               VIA_AUX_CTRL    = IO_PORT_BYTE VIA1, $B
000000r 2               VIA_PER_CTRL    = IO_PORT_BYTE VIA1, $C
000000r 2               VIA_INT_FLAGS   = IO_PORT_BYTE VIA1, $D
000000r 2               VIA_INT_ENABLE  = IO_PORT_BYTE VIA1, $E
000000r 2               
000000r 2               ACIA_DATA       = IO_PORT_BYTE ACIA, 0
000000r 2               ACIA_STATUS     = IO_PORT_BYTE ACIA, 1
000000r 2               ACIA_CMD        = IO_PORT_BYTE ACIA, 2
000000r 2               ACIA_CTRL       = IO_PORT_BYTE ACIA, 3
000000r 2               
000000r 2               ; IRQs, from highest priority (0) to lowest (15)
000000r 2               IRQ_NUMBER_HIGHEST_PRI = 0
000000r 2               IRQ_NUMBER_ONBOARD_VIA = 0         ; System timers, etc
000000r 2               IRQ_NUMBER_ONBOARD_SERIAL = 1      ; On-board serial
000000r 2               
000000r 2               IRQ_NUMBER_SLOT_0_L = 2
000000r 2               IRQ_NUMBER_SLOT_0_H = 3
000000r 2               
000000r 2               IRQ_NUMBER_ONBOARD_SOUND = 4       ; YM-2151
000000r 2               
000000r 2               ; SLOT-assigned IRQs, low (higher-priority)
000000r 2               IRQ_NUMBER_SLOT_1_L = 5
000000r 2               IRQ_NUMBER_SLOT_2_L = 6
000000r 2               IRQ_NUMBER_SLOT_3_L = 7
000000r 2               IRQ_NUMBER_SLOT_4_L = 8
000000r 2               IRQ_NUMBER_SLOT_5_L = 9
000000r 2               
000000r 2               ; SLOT-assigned IRQs, high (lower-priority)
000000r 2               IRQ_NUMBER_SLOT_1_H = 10
000000r 2               IRQ_NUMBER_SLOT_2_H = 11
000000r 2               IRQ_NUMBER_SLOT_3_H = 12
000000r 2               IRQ_NUMBER_SLOT_4_H = 13
000000r 2               IRQ_NUMBER_SLOT_5_H = 14
000000r 2               
000000r 2               IRQ_NUMBER_15 = 15                  ; not assigned to any hardware or slot
000000r 2               IRQ_NUMBER_LOWEST_PRI = 15
000000r 2               IRQ_NUMBER_SW = 15
000000r 2               
000000r 2               YM_REG          = IO_PORT_BYTE YM_SOUND, 0
000000r 2               YM_DATA         = IO_PORT_BYTE YM_SOUND, 1
000000r 2               
000000r 2               ACIA_STATUS_BIT_IRQ  =  $80
000000r 2               ACIA_STATUS_BIT_DSRB =  $40
000000r 2               ACIA_STATUS_BIT_DCD =   $20
000000r 2               ACIA_STATUS_BIT_TDRE =  $10         ; for WDC 65C51, this is never 1 during transmission
000000r 2               ACIA_STATUS_BIT_RDRF =  $08
000000r 2               ACIA_STATUS_BIT_OVR =   $04
000000r 2               ACIA_STATUS_BIT_FE =    $02
000000r 2               ACIA_STATUS_BIT_PE =    $01
000000r 2               
000000r 2               ACIA_CMD_BIT_PME =      $20
000000r 2               ACIA_CMD_BIT_RECHO =    $10
000000r 2               ACIA_CMD_BIT_TLID =     $08
000000r 2               ACIA_CMD_BIT_TLIE =     $04
000000r 2               ACIA_CMD_BIT_RID  =     $02
000000r 2               ACIA_CMD_BIT_RIE  =     $00
000000r 2               ACIA_CMD_BIT_DTRL =     $01
000000r 2               
000000r 2               ; SPI Defines
000000r 2               
000000r 2               IOR_SPI_DATA        = VIA_PORTB
000000r 2               IOR_SPI_DDR         = VIA_DDRB
000000r 2               
000000r 2               ; SPI DATA BITS
000000r 2               SPI_BIT_CLK     = 1     ; bit 0, so INC/DEC cycle the clock
000000r 2               SPI_BIT_CSB     = 2     ; bit 1
000000r 2               SPI_BIT_MOSI    = 4     ; bit 2
000000r 2               SPI_BIT_CS_1    = 8     ; bit 3
000000r 2               SPI_BIT_CS_2    = $10   ; bit 4
000000r 2               SPI_BIT_CS_4    = $20   ; bit 5
000000r 2               SPI_BIT_CS_8    = $40   ; bit 6
000000r 2               SPI_BIT_MISO    = $80   ; bit 7, so BIT opcode stores MISO in N
000000r 2               
000000r 2               SPI_DEV_0       = 0
000000r 2               SPI_DEV_1       = SPI_BIT_CS_1
000000r 2               SPI_DEV_2       = SPI_BIT_CS_2
000000r 2               SPI_DEV_3       = SPI_BIT_CS_2 | SPI_BIT_CS_1
000000r 2               SPI_DEV_4       = SPI_BIT_CS_4
000000r 2               SPI_DEV_5       = SPI_BIT_CS_4 | SPI_BIT_CS_1
000000r 2               SPI_DEV_6       = SPI_BIT_CS_4 | SPI_BIT_CS_2
000000r 2               SPI_DEV_7       = SPI_BIT_CS_4 | SPI_BIT_CS_2 | SPI_BIT_CS_1
000000r 2               
000000r 2               SPI_DEV_8       = SPI_BIT_CS_8 | SPI_DEV_0
000000r 2               SPI_DEV_9       = SPI_BIT_CS_8 | SPI_DEV_1
000000r 2               SPI_DEV_A       = SPI_BIT_CS_8 | SPI_DEV_2
000000r 2               SPI_DEV_B       = SPI_BIT_CS_8 | SPI_DEV_3
000000r 2               SPI_DEV_C       = SPI_BIT_CS_8 | SPI_DEV_4
000000r 2               SPI_DEV_D       = SPI_BIT_CS_8 | SPI_DEV_5
000000r 2               SPI_DEV_E       = SPI_BIT_CS_8 | SPI_DEV_6
000000r 2               SPI_DEV_F       = SPI_BIT_CS_8 | SPI_DEV_7
000000r 2               
000000r 2               SPI_DDR_BITS    = SPI_BIT_CLK | SPI_BIT_CSB | SPI_BIT_MOSI | SPI_DEV_F
000000r 2               
000000r 2               SPI_INIT_DELAY_CYCLES = 80
000000r 2               
000000r 2               ; max task idle
000000r 2               MAX_TASK_NUMBER = $0F           ; 16 tasks, numbered 0-F
000000r 2               NUM_RAM_MODULES = 15            ;
000000r 2               NUM_BANKS_PER_MODULE = 16
000000r 2               NUM_RAM_BANKS   = NUM_RAM_MODULES * NUM_BANKS_PER_MODULE
000000r 2               
000000r 2               T_REGISTER = $FFF0 ; IO_PORT_BYTE IO_PORT_F, 0
000000r 2               U_REGISTER = $FFF1 ; IO_PORT_BYTE IO_PORT_F, 1
000000r 2               V_REGISTER = $FFF2 ; IO_PORT_BYTE IO_PORT_F, 2
000000r 2               W_REGISTER = $FFF3 ; IO_PORT_BYTE IO_PORT_F, 3
000000r 2               
000000r 2               ; ERROR CODES
000000r 2               ERR_NO_TASKS_AVAILABLE = $F1
000000r 2               
000000r 2               ; Task switcher interrupt timer (one interrupt per 5ms or so, with 64 cycles for INT Handler overhead)
000000r 2               TIMER_TASK_INT_H = 69
000000r 2               TIMER_TASK_INT_L = 169
000000r 2               
000000r 2               ; ASCII CODES
000000r 2               ASCII_BACKSPACE = $08
000000r 2               ASCII_LF        = $0A
000000r 2               ASCII_CR        = $0D
000000r 2               ASCII_ESC       = $1B
000000r 2               ASCII_SPACE     = ' '
000000r 2               ASCII_BANG      = '!'
000000r 2               ASCII_DQUOTE    = '"'
000000r 2               ASCII_HASH      = '#'
000000r 2               ASCII_DOLLAR    = '$'
000000r 2               ASCII_PERCENT   = '%'
000000r 2               ASCII_CARET     = '^'
000000r 2               ASCII_AMP       = '&'
000000r 2               ASCII_SQOUTE    = '''
000000r 2               ASCII_LPAREN    = '('
000000r 2               ASCII_RPAREN    = ')'
000000r 2               ASCII_STAR      = '*'
000000r 2               ASCII_PLUS      = '+'
000000r 2               ASCII_COMMA     = ','
000000r 2               ASCII_MINUS     = '-'
000000r 2               ASCII_DASH      = ASCII_MINUS
000000r 2               ASCII_HYPHEN    = ASCII_MINUS
000000r 2               ASCII_PERIOD    = '.'
000000r 2               ASCII_SLASH     = '/'
000000r 2               ASCII_0         = '0'
000000r 2               ASCII_1         = '1'
000000r 2               ASCII_2         = '2'
000000r 2               ASCII_3         = '3'
000000r 2               ASCII_4         = '4'
000000r 2               ASCII_5         = '5'
000000r 2               ASCII_6         = '6'
000000r 2               ASCII_7         = '7'
000000r 2               ASCII_8         = '8'
000000r 2               ASCII_9         = '9'
000000r 2               ASCII_COLON     = ':'
000000r 2               ASCII_SEMI      = ':'
000000r 2               ASCII_LT        = '<'
000000r 2               ASCII_EQ        = '='
000000r 2               ASCII_GT        = '>'
000000r 2               ASCII_QUESTION  = '?'
000000r 2               ASCII_A         = 'A'
000000r 2               ASCII_J         = 'J'
000000r 2               ASCII_R         = 'R'
000000r 2               ASCII_S         = 'S'
000000r 2               ASCII_T         = 'T'
000000r 2               ASCII_U         = 'U'
000000r 2               ASCII_V         = 'V'
000000r 2               ASCII_W         = 'W'
000000r 2               ASCII_X         = 'X'
000000r 2               ASCII_Y         = 'Y'
000000r 2               ASCII_Z         = 'Z'
000000r 2               ASCII_f         = 'f'
000000r 2               ASCII_LBRACKET  = '['
000000r 2               ASCII_BACKSLASH = '\'
000000r 2               ASCII_RBRACKET  = ']'
000000r 2               ASCII_LBRACE    = '{'
000000r 2               ASCII_RBRACE    = '}'
000000r 2               
000000r 2               ASCII_LETTER_OFFSET = ASCII_A-ASCII_0-10
000000r 2               
000000r 2               ; write a byte in A to the IO PORT
000000r 2               .macro IO_PORT_WRITE    port, byte, imm
000000r 2               .ifnblank       imm
000000r 2                               lda     #imm
000000r 2               .endif
000000r 2               .ifblank        byte
000000r 2                               sta     port
000000r 2               .else
000000r 2                               sta     IO_PORT_BYTE port, byte
000000r 2               .endif
000000r 2               .endmacro
000000r 2               
000000r 2               ; read a byte into A from the IO PORT/Byte (PORT_N | BYTE_M)
000000r 2               .macro IO_PORT_READ     port, byte
000000r 2               .ifblank        byte
000000r 2                               lda     port
000000r 2               .else
000000r 2                               lda     IO_PORT_BYTE port, byte
000000r 2               .endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_AX
000000r 2                               pha
000000r 2                               phx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_XA
000000r 2                               plx
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_AY
000000r 2                               pha
000000r 2                               phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_YA
000000r 2                               ply
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_XY
000000r 2                               phx
000000r 2                               phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_YX
000000r 2                               ply
000000r 2                               plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro PUSH_AXY
000000r 2                               pha
000000r 2                               phx
000000r 2                               phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PULL_YXA
000000r 2                               ply
000000r 2                               plx
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               ; convenience macros
000000r 2               
000000r 2               ; MOV
000000r 2               ; Modifies: A
000000r 2               .macro MOV              addr1, addr2
000000r 2                               lda     addr1
000000r 2                               sta     addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVA             addr1, addr2
000000r 2                               MOV     addr1, addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVX             addr1, addr2
000000r 2                               ldx     addr1
000000r 2                               stx     addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVY             addr1, addr2
000000r 2                               ldy     addr1
000000r 2                               sty     addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOV16            addr1, addr2
000000r 2                               lda     addr1
000000r 2                               sta     addr2
000000r 2                               lda     addr1+1
000000r 2                               sta     addr2+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVA16           addr1, addr2
000000r 2                               MOV16   addr1, addr2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVX16           addr1, addr2
000000r 2                               ldx     addr1
000000r 2                               stx     addr2
000000r 2                               ldx     addr1+1
000000r 2                               stx     addr2+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVY16           addr1, addr2
000000r 2                               ldy     addr1
000000r 2                               sty     addr2
000000r 2                               ldy     addr1+1
000000r 2                               sty     addr2+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVAX            addr1, addr2
000000r 2                               lda     addr1,x
000000r 2                               sta     addr2,x
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVAY            addr1, addr2
000000r 2                               lda     addr1,y
000000r 2                               sta     addr2,y
000000r 2               .endmacro
000000r 2               
000000r 2               .macro MOVAY16          addr1, addr2
000000r 2                               lda     addr1,y
000000r 2                               sta     addr2,y
000000r 2                               lda     addr1+1,y
000000r 2                               sta     addr2+1,y
000000r 2               .endmacro
000000r 2               
000000r 2               ; X: # of bytes to move
000000r 2               ; Clobbers A, X
000000r 2               .macro BLKMOVX          addr1, addr2
000000r 2               @:
000000r 2                               dex
000000r 2                               lda     addr1,x
000000r 2                               sta     addr2,x
000000r 2                               bne     @-
000000r 2               .endmacro
000000r 2               
000000r 2               ; Y: # of bytes to move
000000r 2               ; Clobbers A, Y
000000r 2               .macro BLKMOVY          addr1, addr2
000000r 2               @:
000000r 2                               dey
000000r 2                               lda     addr1,y
000000r 2                               sta     addr2,y
000000r 2                               bne     @-
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro  INC16           addr
000000r 2                               inc     addr
000000r 2                               bne     @+
000000r 2                               inc     addr+1
000000r 2                               bra     @++
000000r 2               @:
000000r 2                               lda     addr+1
000000r 2               @:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  INC32           addr
000000r 2                               inc     addr
000000r 2                               bne     @+
000000r 2                               inc     addr+1
000000r 2                               bne     @+
000000r 2                               INC16   addr+2
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  DEC16           addr
000000r 2                               lda     addr
000000r 2                               bne     @+
000000r 2                               dec     addr
000000r 2                               dec     addr+1
000000r 2                               bra     @+++
000000r 2               @:
000000r 2                               dec     addr
000000r 2                               bne     @+      ; if Z not set, don't take Z from HOB
000000r 2                               lda     addr+1  ; sets Z and N from HOB
000000r 2                               bra     @++
000000r 2               @:
000000r 2                               lda     addr+1
000000r 2                               ora     #1      ; reset Z, if set, without affecting N
000000r 2               @:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  DEC32           addr
000000r 2                               lda     addr
000000r 2                               bne     @+++
000000r 2                               cmp     addr+1
000000r 2                               bne     @++
000000r 2                               cmp     addr+2
000000r 2                               bne     @+
000000r 2                               dec     addr+3
000000r 2               @:
000000r 2                               dec     addr+2
000000r 2               @:
000000r 2                               dec     addr+1
000000r 2               @:
000000r 2                               dec     addr
000000r 2               
000000r 2               .endmacro
000000r 2               
000000r 2               ; No-clobber (NC) macros to wrap another macro that overwrites one or more registers
000000r 2               .macro  NC_A            MAC, p1, p2
000000r 2                               pha
000000r 2                               MAC     p1, p2
000000r 2                               pla
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_X            MAC, p1, p2
000000r 2                               phx
000000r 2                               MAC     p1, p2
000000r 2                               plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_Y            MAC, p1, p2
000000r 2                               phy
000000r 2                               MAC     p1, p2
000000r 2                               ply
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_AX           MAC, p1, p2
000000r 2                               PUSH_AX
000000r 2                               MAC     p1, p2
000000r 2                               PULL_XA
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_AY           MAC, p1, p2
000000r 2                               PUSH_AY
000000r 2                               MAC     p1, p2
000000r 2                               PULL_YA
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_XY           MAC, p1, p2
000000r 2                               PUSH_XY
000000r 2                               MAC     p1, p2
000000r 2                               PULL_YX
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  NC_AXY          MAC, p1, p2
000000r 2                               PUSH_AXY
000000r 2                               MAC     p1, p2
000000r 2                               PULL_YXA
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  DEC16_NC_A      addr
000000r 2                               NC_A    DEC16, addr
000000r 2               .endmacro
000000r 2               
000000r 2               .macro SWAP_AX
000000r 2                           pha
000000r 2                           txa
000000r 2                           plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro SWAP_AY
000000r 2                           pha
000000r 2                           tya
000000r 2                           ply
000000r 2               .endmacro
000000r 2               
000000r 1               .include "bios.s"
000000r 2               .debuginfo
000000r 2               
000000r 2               .segment "BIOS"
000000r 2               
000000r 2               .macro SPI_SEND_CMD b0, b1, b2, b3, b4, crc
000000r 2                               lda             #b0 | $40
000000r 2                               jsr             SPI_SEND
000000r 2                               lda             #b1
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               sta             ZP_TEMP_2
000000r 2                               lda             #b2
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               lda             #b3
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               lda             #b4
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2               .ifnblank       crc
000000r 2                               lda             #(crc << 1)+1
000000r 2               .else
000000r 2                               lda             #$FF
000000r 2               .endif
000000r 2                               jsr             SPI_TRANSCEIVE
000000r 2                               jsr             SPI_RECV
000000r 2                               sta             ZP_TEMP
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .define LOADA(arg)      lda     arg
000000r 2               
000000r 2               .macro  LDA_CORA    CharOrAddr
000000r 2               .ifnblank   CharOrAddr
000000r 2                       LOADA CharOrAddr
000000r 2               .endif
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CHAR      C1, C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .ifblank    C1
000000r 2                   .exitmacro
000000r 2               .else
000000r 2                               LDA_CORA        {C1}
000000r 2                               jsr             WRITE_CHAR
000000r 2               .endif
000000r 2                               PRINT_CHAR C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CHAR_JMP  C1, C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .ifblank    C1
000000r 2                   .exitmacro
000000r 2               .else
000000r 2                               LDA_CORA        {C1}
000000r 2                   .ifblank    C2
000000r 2                               jmp             WRITE_CHAR
000000r 2                               .exitmacro
000000r 2                   .else
000000r 2                               jsr             WRITE_CHAR
000000r 2                   .endif
000000r 2               .endif
000000r 2                               PRINT_CHAR_JMP C2, C3, C4, C5, C6, C7, C8, C9
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_ESC_SEQ   C1, C2, C3, C4, C5, C6, C7, C8
000000r 2                               PRINT_CHAR #ASCII_ESC, C1, C2, C3, C4, C5, C6, C7, C8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_ESC_SEQ_JMP   C1, C2, C3, C4, C5, C6, C7, C8
000000r 2                               PRINT_CHAR_JMP #ASCII_ESC, C1, C2, C3, C4, C5, C6, C7, C8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_BYTE      CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jsr             WRITE_BYTE
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_BYTE_JMP  CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jmp             WRITE_BYTE
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_HEX       CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jsr             WRITE_HEX
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_HEX_MASK  CharOrAddr
000000r 2                               LDA_CORA        {CharOrAddr}
000000r 2                               jsr             WRITE_HEX_MASK
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CRLF
000000r 2                               jsr             WRITE_CRLF
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  PRINT_CRLF_JMP
000000r 2                               jmp             WRITE_CRLF
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  JSRR    addrTo, addrFrom
000000r 2                               lda             #>addrFrom
000000r 2                               pha
000000r 2                               lda             #<addrFrom
000000r 2                               pha
000000r 2                               jmp             (addrTo)
000000r 2               .endmacro
000000r 2               
000000r 2  30 31 32 33  HEX_MAP: .byte "0123456789ABCDEF"
000004r 2  34 35 36 37  
000008r 2  38 39 41 42  
000010r 2  18 57 65 6C  HYDRA_WELCOME: HString "Welcome to the HYDRA-16!"
000014r 2  63 6F 6D 65  
000018r 2  20 74 6F 20  
000029r 2               
000029r 2               SERIAL_INIT:
000029r 2  78                           sei
00002Ar 2  A9 10                        lda             #$10 | SR_SELECT    ; 8-N-1
00002Cr 2  8D rr rr                     sta             ACIA_CTRL
00002Fr 2               .if ROCKWELL_ACIA = 1
00002Fr 2  A9 05                        lda             #ACIA_CMD_BIT_DTRL | ACIA_CMD_BIT_TLIE  ; No parity, no echo, tx & rx interrupts.
000031r 2               .else
000031r 2                               lda             #ACIA_CMD_BIT_DTRL | ACIA_CMD_BIT_TLID  ; No parity, no echo, rx interrupts.
000031r 2               .endif
000031r 2  8D rr rr                     sta             ACIA_CMD
000034r 2               .if ROCKWELL_ACIA = 1
000034r 2  64 08                        stz             ZP_SERIAL_SEND_BUSY
000036r 2               .else
000036r 2                               jsr             WRITE_DELAY
000036r 2               .endif
000036r 2  A9 01                        lda             #IRQ_NUMBER_ONBOARD_SERIAL
000038r 2  A2 rr                        ldx             #<SERIAL_IRQ_HANDLER
00003Ar 2  A0 rr                        ldy             #>SERIAL_IRQ_HANDLER
00003Cr 2  20 rr rr                     jsr             IRQ_SET_VECTOR
00003Fr 2  58                           cli
000040r 2  60                           rts
000041r 2               
000041r 2               ; Input a character from the serial interface.
000041r 2               ; On return, carry flag indicates whether a key was pressed
000041r 2               ; If a key was pressed, the key value will be in the A register
000041r 2               ;
000041r 2               ; Modifies: flags, A
000041r 2               ; TODO: select the appropriate read stream for the current task
000041r 2               READ_CHAR:
000041r 2               SERIAL_READ:
000041r 2  20 rr rr                     jsr             BUFFER_SIZE
000044r 2  F0 0F                        beq             @no_keypressed
000046r 2  DA                           phx
000047r 2  A6 10                        ldx             ZP_READ_PTR
000049r 2  BD 00 7F                     lda             INPUT_BUFFER,x
00004Cr 2  E6 10                        inc             ZP_READ_PTR
00004Er 2  FA                           plx
00004Fr 2                               ;cmp             #ASCII_ESC           ; do not echo 'ESC'
00004Fr 2                               ;beq             @no_echo
00004Fr 2  20 rr rr                     jsr             WRITE_CHAR           ; echo
000052r 2               @no_echo:
000052r 2  38                           sec
000053r 2  B0 01                        bcs             @rc_cleanup
000055r 2               
000055r 2               @no_keypressed:
000055r 2  18                           clc
000056r 2               
000056r 2               @rc_cleanup:
000056r 2  60                           rts
000057r 2               
000057r 2               
000057r 2               ; Output a character (from the A register) to the serial interface.
000057r 2               ;
000057r 2               ; Modifies: flags
000057r 2               ; TODO: select appropriate output stream for the given task
000057r 2               WRITE_DEC:
000057r 2  DA                           phx
000058r 2  A2 00                        ldx             #0
00005Ar 2  C9 00                        cmp             #0
00005Cr 2  B0 0E                        bcs             @do_hund
00005Er 2  48                           pha
00005Fr 2  A9 2D 20 rr                  PRINT_CHAR      #ASCII_MINUS
000063r 2  rr           
000064r 2  68                           pla
000065r 2  C9 50                        cmp             #80                         ; special case for -128
000067r 2  F0 2E                        beq             @is_max
000069r 2  20 rr rr                     jsr             NEGATE
00006Cr 2               
00006Cr 2               @do_hund:
00006Cr 2  C9 64                        cmp             #100
00006Er 2  90 0E                        bcc             @do_tens
000070r 2  48                           pha
000071r 2  A9 31 20 rr                  PRINT_CHAR      #ASCII_1                    ; must be 100-127
000075r 2  rr           
000076r 2  68                           pla
000077r 2  38                           sec
000078r 2  E9 64                        sbc             #100
00007Ar 2  C9 0A                        cmp             #10                         ; special case for 100-109..need to print the 0 in tens
00007Cr 2  90 0D                        bcc             @out_tens
00007Er 2               
00007Er 2               @do_tens:
00007Er 2  C9 0A                        cmp             #10
000080r 2  90 11                        bcc             @do_ones
000082r 2               
000082r 2               @gt_ten:
000082r 2  E8                           inx
000083r 2  C9 0A                        cmp             #10
000085r 2  90 04                        bcc             @out_tens
000087r 2  E9 0A                        sbc             #10
000089r 2  10 F7                        bpl             @gt_ten
00008Br 2               
00008Br 2               @out_tens:
00008Br 2  48                           pha
00008Cr 2  8A                           txa
00008Dr 2  69 30                        adc             #ASCII_0
00008Fr 2  20 rr rr                     jsr             WRITE_CHAR
000092r 2  68                           pla
000093r 2               
000093r 2               @do_ones:
000093r 2  FA                           plx
000094r 2  4C rr rr                     jmp             WRITE_HEX
000097r 2               
000097r 2               @is_max:
000097r 2  A9 31 20 rr                  PRINT_CHAR      #ASCII_1
00009Br 2  rr           
00009Cr 2  A9 1C                        lda             #28
00009Er 2  10 DE                        bpl             @do_tens
0000A0r 2               
0000A0r 2               WRITE_BYTE_MIN:
0000A0r 2  C9 10                        cmp             #$10
0000A2r 2  90 0B                        bcc             WRITE_HEX
0000A4r 2               
0000A4r 2               WRITE_BYTE:
0000A4r 2  48                           pha                                         ; Save A for LSD.
0000A5r 2  4A                           lsr
0000A6r 2  4A                           lsr
0000A7r 2  4A                           lsr
0000A8r 2  4A                           lsr                                         ; MSD to LSD position.
0000A9r 2  20 rr rr                     jsr             WRITE_HEX                   ; Output hex digit.
0000ACr 2  68                           pla                                         ; Restore A.
0000ADr 2               WRITE_HEX_MASK:
0000ADr 2  29 0F                        and             #$0F                        ; Mask LSD for hex print.
0000AFr 2               
0000AFr 2               WRITE_HEX:
0000AFr 2  DA                           phx
0000B0r 2  AA                           tax
0000B1r 2  BD rr rr                     lda             HEX_MAP,x
0000B4r 2  FA                           plx
0000B5r 2                               ; Then fall through to WRITE_CHAR below.
0000B5r 2               
0000B5r 2               WRITE_CHAR:
0000B5r 2               SERIAL_WRITE:
0000B5r 2               .if ROCKWELL_ACIA = 1
0000B5r 2  DA                           phx
0000B6r 2               WRITE_DELAY:
0000B6r 2  A6 08                        ldx             ZP_SERIAL_SEND_BUSY
0000B8r 2  F0 03                        beq             @do_write
0000BAr 2  CB                           wai                                         ; Leave this in, even if RDY has a pull-up
0000BBr 2  80 F9                        bra            WRITE_DELAY
0000BDr 2               .endif
0000BDr 2               @do_write:
0000BDr 2  8D rr rr                     IO_PORT_WRITE   ACIA_DATA
0000C0r 2               
0000C0r 2               .if ROCKWELL_ACIA = 1
0000C0r 2  A2 01                        ldx             #1
0000C2r 2  86 08                        stx             ZP_SERIAL_SEND_BUSY
0000C4r 2               .else
0000C4r 2               WRITE_DELAY:
0000C4r 2                               phx
0000C4r 2                               ldx             #SWT_SELECT
0000C4r 2               @txdelay:
0000C4r 2                               dex
0000C4r 2                               bne             @txdelay
0000C4r 2               .endif
0000C4r 2  FA                           plx
0000C5r 2  60                           rts
0000C6r 2               
0000C6r 2               ; Convenience method to write CR/LF to output stream
0000C6r 2               WRITE_CRLF:
0000C6r 2  A9 0D 20 rr                  PRINT_CHAR      #ASCII_CR
0000CAr 2  rr           
0000CBr 2  A9 0A 4C rr                  PRINT_CHAR_JMP  #ASCII_LF
0000CFr 2  rr           
0000D0r 2               
0000D0r 2               WRITE_PROMPT:
0000D0r 2  20 rr rr                     PRINT_CRLF
0000D3r 2  A9 54 20 rr                  PRINT_CHAR      #ASCII_T
0000D7r 2  rr           
0000D8r 2  AD F0 FF 20                  PRINT_HEX_MASK  $FFF0
0000DCr 2  rr rr        
0000DEr 2  A9 20 20 rr                  PRINT_CHAR      #ASCII_SPACE
0000E2r 2  rr           
0000E3r 2  A5 00 20 rr                  PRINT_BYTE      $0
0000E7r 2  rr           
0000E8r 2  A5 00                        lda             $0
0000EAr 2  C9 F0                        cmp             #$F0
0000ECr 2  90 10                        bcc             @not_shared
0000EEr 2  A9 28 20 rr                  PRINT_CHAR      #ASCII_LPAREN
0000F2r 2  rr           
0000F3r 2  AD F1 FF 20                  PRINT_HEX_MASK  $FFF1                       ; Shared RAM sub-bank
0000F7r 2  rr rr        
0000F9r 2  A9 29 20 rr                  PRINT_CHAR      #ASCII_RPAREN
0000FDr 2  rr           
0000FEr 2               
0000FEr 2               @not_shared:
0000FEr 2  A9 3A 20 rr                  PRINT_CHAR      #ASCII_COLON
000102r 2  rr           
000103r 2  A5 01 20 rr                  PRINT_BYTE      $1
000107r 2  rr           
000108r 2  A9 3E 4C rr                  PRINT_CHAR_JMP  #ASCII_GT
00010Cr 2  rr           
00010Dr 2               
00010Dr 2               ; Initialize the circular input buffer
00010Dr 2               ; Modifies: flags, A
00010Dr 2               INIT_BUFFER:
00010Dr 2  A5 10 85 11                  MOV             ZP_READ_PTR, ZP_WRITE_PTR
000111r 2  60                           rts
000112r 2               
000112r 2               ; Escape sequences
000112r 2               CLEAR_SCR:
000112r 2  A9 1B 20 rr                  PRINT_ESC_SEQ #ASCII_LBRACKET, #ASCII_2, #ASCII_J
000116r 2  rr A9 5B 20  
00011Ar 2  rr rr A9 32  
000126r 2  A9 1B 20 rr                  PRINT_ESC_SEQ_JMP #ASCII_LBRACKET, #ASCII_0, #ASCII_SEMI, #ASCII_0, #ASCII_f
00012Ar 2  rr A9 5B 20  
00012Er 2  rr rr A9 30  
000144r 2               
000144r 2               ; Set up the SPI interface registers on the VIA
000144r 2               SPI_INIT:
000144r 2  48                           pha
000145r 2  A9 00 8D rr                  IO_PORT_WRITE   VIA_AUX_CTRL, , 0
000149r 2  rr           
00014Ar 2  8D rr rr                     IO_PORT_WRITE   VIA_INT_ENABLE
00014Dr 2  A9 FF 8D rr                  IO_PORT_WRITE   VIA_PER_CTRL, , $FF
000151r 2  rr           
000152r 2  A9 7F 8D rr                  IO_PORT_WRITE   IOR_SPI_DDR,  , SPI_DDR_BITS
000156r 2  rr           
000157r 2  A9 02 8D rr                  IO_PORT_WRITE   IOR_SPI_DATA, , SPI_BIT_CSB   ; de-select all SPI devices
00015Br 2  rr           
00015Cr 2  68                           pla
00015Dr 2  60                           rts
00015Er 2               
00015Er 2               ; Macro to remove essentially duplicate code
00015Er 2               .macro          SPI_SEND_SETUP  mode
00015Er 2                               sta             ZP_SPI_DATA_OUT
00015Er 2                               phy
00015Er 2                               txa
00015Er 2                               ora             #SPI_BIT_MOSI
00015Er 2                               tay
00015Er 2                               lda             ZP_SPI_DATA_OUT
00015Er 2                               sei
00015Er 2               .ifblank        mode
00015Er 2                               asl             ZP_SPI_DATA_IN
00015Er 2               .endif
00015Er 2                               sec
00015Er 2                               rol
00015Er 2               .endmacro
00015Er 2               
00015Er 2               ; Write and Read SPI data
00015Er 2               ; Uses two ZP registers for data_in and data_out
00015Er 2               ; A: data to send
00015Er 2               ; X: device ID to send to/receive from
00015Er 2               ; Returns input data in A
00015Er 2               ; Modifies A, ZP_SPI_DATA_IN, ZP_SPI_DATA_OUT
00015Er 2               SPI_TRANSCEIVE:
00015Er 2  85 15 5A 8A                  SPI_SEND_SETUP
000162r 2  09 04 A8 A5  
000166r 2  15 78 06 14  
00016Cr 2  B0 05                        bcs             @spi_send_1
00016Er 2               @spi_send_0:
00016Er 2  8E rr rr                     stx             IOR_SPI_DATA
000171r 2  80 03                        bra             @spi_send
000173r 2               @spi_send_1:
000173r 2  8C rr rr                     sty             IOR_SPI_DATA
000176r 2               @spi_send:
000176r 2  EE rr rr                     inc             IOR_SPI_DATA        ; SPI_CLK = 1
000179r 2  2C rr rr                     bit             IOR_SPI_DATA        ; MISO (bit 7) => N flag
00017Cr 2  10 02                        bpl             @spi_recv
00017Er 2  E6 14                        inc             ZP_SPI_DATA_IN      ; incoming bit was a 1 (set LSb = 1)
000180r 2               @spi_recv:
000180r 2  0A                           asl
000181r 2  F0 0A                        beq             SPI_OPERATION_DONE
000183r 2  B0 04                        bcs             @had_1
000185r 2  06 14                        asl             ZP_SPI_DATA_IN
000187r 2  80 E5                        bra             @spi_send_0
000189r 2               @had_1:
000189r 2  06 14                        asl             ZP_SPI_DATA_IN
00018Br 2  80 E6                        bra             @spi_send_1
00018Dr 2               
00018Dr 2               SPI_OPERATION_DONE:
00018Dr 2  A9 02                        lda             #SPI_BIT_CSB        ; de-select all SPI devices
00018Fr 2  0C rr rr                     tsb             IOR_SPI_DATA
000192r 2  7A                           ply
000193r 2  A5 14                        lda             ZP_SPI_DATA_IN      ; load the input for return in A
000195r 2  58                           cli
000196r 2  60                           rts
000197r 2               
000197r 2               ; Write SPI data
000197r 2               ; Uses two ZP registers for data_in and data_out
000197r 2               ; A: data to send
000197r 2               ; X: device ID to send to
000197r 2               ; Modifies A, ZP_SPI_DATA_OUT
000197r 2               SPI_SEND:
000197r 2  85 15 5A 8A                  SPI_SEND_SETUP  1
00019Br 2  09 04 A8 A5  
00019Fr 2  15 78 38 2A  
0001A3r 2               @send_loop:
0001A3r 2  B0 05                        bcs             @spi_send_1
0001A5r 2  8E rr rr                     stx             IOR_SPI_DATA
0001A8r 2  80 03                        bra             @spi_send
0001AAr 2               @spi_send_1:
0001AAr 2  8C rr rr                     sty             IOR_SPI_DATA
0001ADr 2               @spi_send:
0001ADr 2  EE rr rr                     inc             IOR_SPI_DATA        ; SPI_CLK = 1
0001B0r 2  0A                           asl
0001B1r 2  D0 F0                        bne             @send_loop
0001B3r 2  4C rr rr                     jmp             SPI_OPERATION_DONE
0001B6r 2               
0001B6r 2               ; Read from the SPI device
0001B6r 2               ; X: device to read from
0001B6r 2               ; Result returned in A
0001B6r 2               SPI_RECV:
0001B6r 2  5A                           phy
0001B7r 2  A0 08                        ldy             #8
0001B9r 2  8A                           txa
0001BAr 2  09 06                        ora             #SPI_BIT_MOSI | SPI_BIT_CSB
0001BCr 2  8D rr rr                     sta             IOR_SPI_DATA        ; Select the device to receive from
0001BFr 2  78                           sei
0001C0r 2               @recv_loop:
0001C0r 2  0A                           asl                                 ; Shift in 0 to LSb of result
0001C1r 2  EE rr rr                     inc             IOR_SPI_DATA
0001C4r 2  2C rr rr                     bit             IOR_SPI_DATA        ; MISO (bit 7) => N flag
0001C7r 2  10 01                        bpl             @spi_recv_2
0001C9r 2                                                                   ; Set LSb = 1
0001C9r 2  1A                           inc
0001CAr 2               @spi_recv_2:
0001CAr 2  88                           dey
0001CBr 2  D0 F3                        bne             @recv_loop
0001CDr 2  85 14                        sta             ZP_SPI_DATA_IN
0001CFr 2  4C rr rr                     jmp             SPI_OPERATION_DONE
0001D2r 2               
0001D2r 2               ; Delay for some number of cycles to ensure SPI device is ready to start working
0001D2r 2               SPI_INIT_DELAY:
0001D2r 2  48 DA 5A                     PUSH_AXY
0001D5r 2  8A                           txa                                         ; set SPI device
0001D6r 2  09 06                        ora             #SPI_BIT_CSB | SPI_BIT_MOSI ; de-select all devices
0001D8r 2  AA                           tax
0001D9r 2  09 01                        ora             #SPI_BIT_CLK
0001DBr 2  A0 50                        ldy             #SPI_INIT_DELAY_CYCLES
0001DDr 2               @loop:
0001DDr 2  8D rr rr                     sta             IOR_SPI_DATA
0001E0r 2  8E rr rr                     stx             IOR_SPI_DATA
0001E3r 2  88                           dey
0001E4r 2  D0 F7                        bne             @loop
0001E6r 2  7A FA 68                     PULL_YXA
0001E9r 2  60                           rts
0001EAr 2               
0001EAr 2               ; Return (in A) the number of unread bytes in the circular input buffer as an unsigned byte
0001EAr 2               ; Modifies: flags, A
0001EAr 2               BUFFER_SIZE:
0001EAr 2  A5 11                        lda             ZP_WRITE_PTR
0001ECr 2  38                           sec
0001EDr 2  E5 10                        sbc             ZP_READ_PTR
0001EFr 2  60                           rts
0001F0r 2               
0001F0r 2               ; Maskable interrupt request handler; by default, do nothing
0001F0r 2               IRQ_HANDLER:
0001F0r 2  40                           rti
0001F1r 2               
0001F1r 2               
0001F1r 2               SERIAL_IRQ_HANDLER:
0001F1r 2  48                           pha
0001F2r 2               
0001F2r 2               .if ROCKWELL_ACIA = 1
0001F2r 2  A9 10                        lda             #ACIA_STATUS_BIT_TDRE
0001F4r 2               .endif
0001F4r 2               
0001F4r 2  2C rr rr                     bit             ACIA_STATUS
0001F7r 2  10 17                        bpl             @int_done 	            ; bit 7 not set, so not ACIA IRQ
0001F9r 2               
0001F9r 2               .if ROCKWELL_ACIA = 1
0001F9r 2  F0 09                        beq             @do_recv                ; if not Tx, then must be Rx
0001FBr 2  64 08                        stz             ZP_SERIAL_SEND_BUSY
0001FDr 2               
0001FDr 2               @check_recv:
0001FDr 2  A9 08                        lda             #ACIA_STATUS_BIT_RDRF   ; is read register full?
0001FFr 2  2C rr rr                     bit             ACIA_STATUS
000202r 2  F0 0C                        beq             @int_done
000204r 2               .endif
000204r 2               
000204r 2               @do_recv:
000204r 2  AD rr rr                     IO_PORT_READ    ACIA_DATA
000207r 2  DA                           phx
000208r 2  A6 11                        ldx             ZP_WRITE_PTR
00020Ar 2  9D 00 7F                     sta             INPUT_BUFFER, X
00020Dr 2  E6 11                        inc             ZP_WRITE_PTR
00020Fr 2  FA                           plx
000210r 2               
000210r 2               @int_done:
000210r 2  68                           pla
000211r 2  40                           rti
000212r 2               
000212r 2               ;; *****************************************************************
000212r 2               .if 0
000212r 2               ; I2C
000212r 2               
000212r 2               I2C_SCL = $01
000212r 2               I2C_SDA = $02
000212r 2               I2C_CTRL_PORT = VIA_PORTA
000212r 2               I2C_DATA_PORT = VIA_DDRA
000212r 2               
000212r 2               .macro I2C_ON       val
000212r 2                           tay
000212r 2                           lda     #val
000212r 2                           ora     I2C_DATA_PORT
000212r 2                           sta     I2C_DATA_PORT
000212r 2                           tya
000212r 2               .endmacro
000212r 2               
000212r 2               .macro I2C_OFF      val
000212r 2                           tay
000212r 2                           lda     #~val
000212r 2                           and     I2C_DATA_PORT
000212r 2                           sta     I2C_DATA_PORT
000212r 2                           tya
000212r 2               .endmacro
000212r 2               
000212r 2               .macro SDA_LOW
000212r 2                           I2C_OFF I2C_SDA
000212r 2               .endmacro
000212r 2               
000212r 2               .macro SCL_LOW
000212r 2                           I2C_OFF I2C_SCL
000212r 2               .endmacro
000212r 2               
000212r 2               .macro SDA_HIGH
000212r 2                           I2C_ON  I2C_SDA
000212r 2               .endmacro
000212r 2               
000212r 2               .macro SCL_HIGH
000212r 2                           I2C_ON  I2C_SDA
000212r 2               .endmacro
000212r 2               
000212r 2               .macro SCL_PULSE
000212r 2                           inc     I2C_DATA_PORT
000212r 2                           dec     I2C_DATA_PORT
000212r 2               .endmacro
000212r 2               
000212r 2               ; A: Byte to send
000212r 2               ; Return (in A): 1 = SUCCESS, 0 = FAILURE
000212r 2               I2C_SEND:
000212r 2                           ldx     #$00
000212r 2                           stx     I2C_CTRL_PORT
000212r 2                           ldx     #$09
000212r 2               @loop:
000212r 2                           dex
000212r 2                           beq     @ack
000212r 2                           rol
000212r 2                           jsr     I2C_SEND_BIT
000212r 2                           bra    @loop
000212r 2               @ack:
000212r 2                           jsr     I2C_RECV_BIT    ; ack in A, 0 = success
000212r 2                           eor     #$01            ; return 1 on success, 0 on fail
000212r 2               @end:
000212r 2                           rts
000212r 2               
000212r 2               
000212r 2               I2C_RECV:   lda     #$00
000212r 2                           sta     I2C_CTRL_PORT
000212r 2                           pha
000212r 2                           ldx     #$09
000212r 2               @loop:      dex
000212r 2                           beq     @end
000212r 2                           jsr     rec_bit
000212r 2                           ror
000212r 2                           pla
000212r 2                           rol
000212r 2                           pha
000212r 2                           jmp     @loop
000212r 2               @end:
000212r 2                           pla
000212r 2                           rts
000212r 2               
000212r 2               ; A: Bit to send
000212r 2               I2C_SEND_BIT:
000212r 2                           bcc     @send_one
000212r 2                           SDA_LOW
000212r 2                           bra    @clock_out
000212r 2               @send_one:
000212r 2                           SDA_HIGH
000212r 2               
000212r 2               @clock_out:
000212r 2                           SCL_PULSE
000212r 2                           SDA_LOW
000212r 2                           rts
000212r 2               
000212r 2               I2C_RECV_BIT:
000212r 2                           SDA_HIGH
000212r 2                           SCL_HIGH
000212r 2                           lda     I2C_CTRL_PORT
000212r 2                           and     #I2C_SDA
000212r 2                           bne     @is_one
000212r 2                           lda     #$00
000212r 2                           jmp     @end
000212r 2               @is_one:
000212r 2                           lda     #$01
000212r 2               @end:
000212r 2                           SCL_LOW
000212r 2                           SDA_LOW
000212r 2                           rts
000212r 2               
000212r 2               
000212r 2               I2C_START:
000212r 2                           SDA_LOW
000212r 2                           SCL_LOW
000212r 2                           rts
000212r 2               
000212r 2               
000212r 2               I2C_STOP:
000212r 2                           SCL_HIGH
000212r 2                           SDA_HIGH
000212r 2                           rts
000212r 2               
000212r 2               
000212r 2               I2C_ACK:
000212r 2                           pha
000212r 2                           lda     #$00
000212r 2                           jsr     I2C_SEND_BIT
000212r 2                           pla
000212r 2                           rts
000212r 2               
000212r 2               I2C_NACK:
000212r 2                           pha
000212r 2                           lda     #$01
000212r 2                           jsr     I2C_SEND_BIT
000212r 2                           pla
000212r 2                           rts
000212r 2               .endif
000212r 2               
000212r 2               ; ****************************************************************************
000212r 2               
000212r 2               IRQ_VECTOR_INIT:
000212r 2  78                       sei
000213r 2  48 DA                    PUSH_AX
000215r 2  A2 0F                    ldx     #$0F
000217r 2  8E F2 FF                 stx     V_REGISTER
00021Ar 2  A9 rr                    lda     #<SW_IRQ_HANDLER
00021Cr 2  8D FE FF                 sta     $FFFE
00021Fr 2  A9 rr                    lda     #>SW_IRQ_HANDLER
000221r 2  8D FF FF                 sta     $FFFF
000224r 2  CA                       dex
000225r 2               
000225r 2               @loop:
000225r 2  8E F2 FF                 stx     V_REGISTER
000228r 2  A9 rr                    lda     #<SERIAL_IRQ_HANDLER
00022Ar 2  8D FE FF                 sta     $FFFE
00022Dr 2  A9 rr                    lda     #>SERIAL_IRQ_HANDLER
00022Fr 2  8D FF FF                 sta     $FFFF
000232r 2  CA                       dex
000233r 2  10 F0                    bpl     @loop
000235r 2  FA 68                    PULL_XA
000237r 2  58                       cli
000238r 2  60                       rts
000239r 2               
000239r 2               ; A: IRQ#, X: L, Y: H
000239r 2               IRQ_SET_VECTOR:
000239r 2  78                       sei
00023Ar 2  48                       pha
00023Br 2  AD F2 FF                 lda     V_REGISTER
00023Er 2  85 1D                    sta     ZP_V_SAVE
000240r 2  68                       pla
000241r 2  8D F2 FF                 sta     V_REGISTER
000244r 2  8E FE FF                 stx     $FFFE
000247r 2  8C FF FF                 sty     $FFFF
00024Ar 2  A5 1D                    lda     ZP_V_SAVE
00024Cr 2  8D F2 FF                 sta     V_REGISTER
00024Fr 2  58                       cli
000250r 2  60                       rts
000251r 2               
000251r 2               SW_IRQ_HANDLER:
000251r 2  48                       pha
000252r 2  4A                       lsr
000253r 2  4A                       lsr
000254r 2  4A                       lsr
000255r 2  4A                       lsr
000256r 2  68                       pla
000257r 2  40                       rti
000258r 2               
000258r 2               .segment "IO_PORTS"
000000r 2  xx xx xx xx  IO_PORT_0:      .tag IO_Port
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
000010r 2  xx xx xx xx  IO_PORT_1:      .tag IO_Port
000014r 2  xx xx xx xx  
000018r 2  xx xx xx xx  
000020r 2  xx xx xx xx  IO_PORT_2:      .tag IO_Port
000024r 2  xx xx xx xx  
000028r 2  xx xx xx xx  
000030r 2  xx xx xx xx  IO_PORT_3:      .tag IO_Port
000034r 2  xx xx xx xx  
000038r 2  xx xx xx xx  
000040r 2  xx xx xx xx  IO_PORT_4:      .tag IO_Port
000044r 2  xx xx xx xx  
000048r 2  xx xx xx xx  
000050r 2  xx xx xx xx  IO_PORT_5:      .tag IO_Port
000054r 2  xx xx xx xx  
000058r 2  xx xx xx xx  
000060r 2  xx xx xx xx  IO_PORT_6:      .tag IO_Port
000064r 2  xx xx xx xx  
000068r 2  xx xx xx xx  
000070r 2  xx xx xx xx  IO_PORT_7:      .tag IO_Port
000074r 2  xx xx xx xx  
000078r 2  xx xx xx xx  
000080r 2  xx xx xx xx  IO_PORT_8:      .tag IO_Port
000084r 2  xx xx xx xx  
000088r 2  xx xx xx xx  
000090r 2  xx xx xx xx  IO_PORT_9:      .tag IO_Port
000094r 2  xx xx xx xx  
000098r 2  xx xx xx xx  
0000A0r 2  xx xx xx xx  IO_PORT_A:      .tag IO_Port
0000A4r 2  xx xx xx xx  
0000A8r 2  xx xx xx xx  
0000B0r 2  xx xx xx xx  IO_PORT_B:      .tag IO_Port
0000B4r 2  xx xx xx xx  
0000B8r 2  xx xx xx xx  
0000C0r 2  xx xx xx xx  IO_PORT_C:      .tag IO_Port
0000C4r 2  xx xx xx xx  
0000C8r 2  xx xx xx xx  
0000D0r 2  xx xx xx xx  IO_PORT_D:      .tag IO_Port
0000D4r 2  xx xx xx xx  
0000D8r 2  xx xx xx xx  
0000E0r 2  xx xx xx xx  IO_PORT_E:      .tag IO_Port
0000E4r 2  xx xx xx xx  
0000E8r 2  xx xx xx xx  
0000F0r 2  xx xx xx xx  IO_PORT_F:      .tag IO_Port_10_Bytes
0000F4r 2  xx xx xx xx  
0000F8r 2  xx xx        
0000FAr 2               
0000FAr 2               .macro VECTORS
0000FAr 2                               .word   NMI_HANDLER     ; NMI vector
0000FAr 2                               .word   RESET_ENTRY     ; RESET vector
0000FAr 2                               .word   IRQ_HANDLER     ; IRQ vector
0000FAr 2                               ;       will actually be pulled from the Vector RAM, depending on lowest priority IRQ currently triggered,
0000FAr 2                               ;       or vector for IRQ# set in V[0..3] if none are triggered.  Can trigger S/W IRQs by setting V and then
0000FAr 2                               ;       calling BRK.  S/W IRQ# is $F, so setting V[0..3] to $F and v[4..7] to a different number, you can
0000FAr 2                               ;       have up to 16 unique S/W IRQs.  You can invoke a hardware device IRQ handler in the same way
0000FAr 2               .endmacro
0000FAr 2               
0000FAr 2               .segment "RESETVEC_P0"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P1"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P2"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P3"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P4"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P5"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P6"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P7"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P8"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_P9"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_PA"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_PB"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_PC"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_PD"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_PE"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 2               .segment "RESETVEC_PF"
000000r 2  rr rr rr rr      VECTORS
000004r 2  rr rr        
000006r 2               
000006r 1               .include "math.s"
000006r 2               .debuginfo
000006r 2               
000006r 2               .segment "BIOS"
000258r 2               
000258r 2               ; MATH
000258r 2               MOD_10:
000258r 2  C9 00                    cmp             #0
00025Ar 2  30 10                    bmi             @negative
00025Cr 2  C9 64                    cmp             #100
00025Er 2  30 02                    bmi             @positive
000260r 2  E9 64                    sbc             #100
000262r 2               
000262r 2               @positive:
000262r 2  38                       sec
000263r 2               
000263r 2               @pos_loop:
000263r 2  E9 0A                    sbc             #10
000265r 2  F0 04                    beq             @pos_end
000267r 2  10 FA                    bpl             @pos_loop
000269r 2  69 0A                    adc             #10
00026Br 2               
00026Br 2               @pos_end:
00026Br 2  60                       rts
00026Cr 2               
00026Cr 2               @negative:
00026Cr 2  C9 A6                    cmp             #$A6            ; -90
00026Er 2  10 02                    bpl             @neg_start
000270r 2  69 A6                    adc             #$A6
000272r 2               
000272r 2               @neg_start:
000272r 2  18                       clc
000273r 2               
000273r 2               @neg_loop:
000273r 2  69 0A                    adc             #10
000275r 2  30 FC                    bmi             @neg_loop
000277r 2  60                       rts
000278r 2               
000278r 2               REM_10:
000278r 2  A2 00                    ldx             #0
00027Ar 2  C9 00                    cmp             #0
00027Cr 2  30 14                    bmi             @negative
00027Er 2  C9 64                    cmp             #100
000280r 2  30 04                    bmi             @positive
000282r 2  E9 64                    sbc             #100
000284r 2  A2 0A                    ldx             #10
000286r 2               
000286r 2               @positive:
000286r 2  38                       sec
000287r 2               
000287r 2               @pos_loop:
000287r 2  E8                       inx
000288r 2  E9 0A                    sbc             #10
00028Ar 2  F0 05                    beq             @pos_end
00028Cr 2  10 F9                    bpl             @pos_loop
00028Er 2  CA                       dex
00028Fr 2  69 0A                    adc             #10
000291r 2               
000291r 2               @pos_end:
000291r 2  60                       rts
000292r 2               
000292r 2               @negative:
000292r 2  C9 9B                    cmp             #$9B            ; -99
000294r 2  10 04                    bpl             @neg_start
000296r 2  69 9B                    adc             #$9B
000298r 2  A2 F6                    ldx             #$F6            ; -10
00029Ar 2               
00029Ar 2               @neg_start:
00029Ar 2  18                       clc
00029Br 2               
00029Br 2               @neg_loop:
00029Br 2  CA                       dex
00029Cr 2  69 0A                    adc             #10
00029Er 2  30 FB                    bmi             @neg_loop
0002A0r 2  F0 04                    beq             @neg_end
0002A2r 2  E8                       inx
0002A3r 2  38                       sec
0002A4r 2  E9 0A                    sbc             #10
0002A6r 2               
0002A6r 2               @neg_end:
0002A6r 2  60                       rts
0002A7r 2               
0002A7r 2               DIV_10:
0002A7r 2  20 rr rr                 jsr             REM_10
0002AAr 2  48 8A FA                 SWAP_AX
0002ADr 2  60                       rts
0002AEr 2               
0002AEr 2               ABS:
0002AEr 2  C9 00                    cmp             #0
0002B0r 2  B0 03                    bcs             INV_DONE
0002B2r 2               
0002B2r 2               NEGATE:
0002B2r 2  1A                       inc
0002B3r 2               
0002B3r 2               INVERT:
0002B3r 2  49 FF                    eor             #$FF
0002B5r 2               
0002B5r 2               INV_DONE:
0002B5r 2  60                       rts
0002B6r 2               
0002B6r 2               
0002B6r 1               .include "sound.s"
0002B6r 2               ; zero out all YM-2151 registers $28-$FF
0002B6r 2               SOUND_INIT:
0002B6r 2  48                           pha
0002B7r 2  DA                           phx
0002B8r 2  A9 00                        lda         #0
0002BAr 2  A2 28                        ldx         #$28
0002BCr 2               
0002BCr 2               @write_z:
0002BCr 2  20 rr rr                     jsr         YM_WRITE
0002BFr 2  B0 0D                        bcs         @error
0002C1r 2  E8                           inx
0002C2r 2  D0 F8                        bne         @write_z
0002C4r 2  A9 04                        lda         #IRQ_NUMBER_ONBOARD_SOUND
0002C6r 2  A2 rr                        ldx         #<SOUND_IRQ_HANDLER
0002C8r 2  A0 rr                        ldy         #>SOUND_IRQ_HANDLER
0002CAr 2  20 rr rr                     jsr         IRQ_SET_VECTOR
0002CDr 2  18                           clc
0002CEr 2               
0002CEr 2               @error:
0002CEr 2  FA                           plx
0002CFr 2  68                           pla
0002D0r 2  60                           rts
0002D1r 2               
0002D1r 2               
0002D1r 2               SOUND_IRQ_HANDLER:
0002D1r 2                               ; check which
0002D1r 2  60                           rts
0002D2r 2               
0002D2r 2               YMN0L = $A0
0002D2r 2               YMN0H = YMN0L + 1
0002D2r 2               YMN1L = YMN0L + 2
0002D2r 2               YMN1H = YMN0L + 3
0002D2r 2               
0002D2r 2               AZP0L = $B0
0002D2r 2               AZP0H = AZP0L + 1
0002D2r 2               YMTMP1 = AZP0L + 2
0002D2r 2               YMTMP2 = AZP0L + 3
0002D2r 2               
0002D2r 2               ;C# = 0
0002D2r 2               ;D  = 1
0002D2r 2               ;D# = 2
0002D2r 2               ;E  = 4
0002D2r 2               ;F  = 5
0002D2r 2               ;F# = 6
0002D2r 2               ;G  = 8
0002D2r 2               ;G# = 9
0002D2r 2               ;A  = A
0002D2r 2               ;A# = C
0002D2r 2               ;B  = D
0002D2r 2               ;C  = E
0002D2r 2               
0002D2r 2               ;$20+C, $38+C
0002D2r 2               ;$40+C - $78+C
0002D2r 2               ;$80+C - $B8+C
0002D2r 2               ;$C0+C - $F8+C
0002D2r 2               
0002D2r 2               M027_Electric_Clean_Guitar:
0002D2r 2  F8 00        	.byte $F8,$00
0002D4r 2  29 31 21 31  	.byte $29,$31,$21,$31,$2E,$1E,$0F,$00
0002D8r 2  2E 1E 0F 00  
0002DCr 2  1F 1F 1F 1F  	.byte $1F,$1F,$1F,$1F,$10,$04,$08,$09
0002E0r 2  10 04 08 09  
0002E4r 2  00 00 00 00  	.byte $00,$00,$00,$00,$F9,$B1,$F4,$FB
0002E8r 2  F9 B1 F4 FB  
0002ECr 2               
0002ECr 2               M028_Electric_Muted_Guitar:
0002ECr 2  E2 00        	.byte $E2,$00
0002EEr 2  54 51 01 01  	.byte $54,$51,$01,$01,$20,$21,$32,$00
0002F2r 2  20 21 32 00  
0002F6r 2  1C 1F 1F 1F  	.byte $1C,$1F,$1F,$1F,$15,$02,$03,$0A
0002FAr 2  15 02 03 0A  
0002FEr 2  00 00 00 00  	.byte $00,$00,$00,$00,$FF,$B1,$F4,$F9
000302r 2  FF B1 F4 F9  
000306r 2               
000306r 2               M029_Electric_Overdriven_Guitar:
000306r 2  FA 00        	.byte $FA,$00
000308r 2  33 11 32 33  	.byte $33,$11,$32,$33,$10,$16,$21,$00
00030Cr 2  10 16 21 00  
000310r 2  1F 1F 1F 1F  	.byte $1F,$1F,$1F,$1F,$17,$08,$02,$03
000314r 2  17 08 02 03  
000318r 2  00 00 00 00  	.byte $00,$00,$00,$00,$FF,$B1,$F4,$FB
00031Cr 2  FF B1 F4 FB  
000320r 2               
000320r 2               M030_Electric_Distorted_Guitar:
000320r 2  FA 00        	.byte $FA,$00
000322r 2  33 11 31 33  	.byte $33,$11,$31,$33,$09,$0B,$1A,$00
000326r 2  09 0B 1A 00  
00032Ar 2  1F 1F 1F 1F  	.byte $1F,$1F,$1F,$1F,$17,$00,$00,$07
00032Er 2  17 00 00 07  
000332r 2  00 00 00 00  	.byte $00,$00,$00,$00,$FF,$B1,$F4,$FB
000336r 2  FF B1 F4 FB  
00033Ar 2               
00033Ar 2               GUITAR_PATCH = M029_Electric_Overdriven_Guitar
00033Ar 2               
00033Ar 2               ; Note data for Sweet Child o' Mine (first 4 bars)
00033Ar 2               SCOM_NOTES_0:   ;            D4,  D4,  E4,  E4,  G4,  G4,  D4,  D4
00033Ar 2                               ;.byte       $41, $41, $44, $44, $48, $48, $41, $41
00033Ar 2  40 40 42 42                  .byte       $40, $40, $42, $42, $46, $46, $40, $40 ; half-note flat, just like Slash
00033Er 2  46 46 40 40  
000342r 2               
000342r 2               SCOM_NOTES_1:
000342r 2                               ;            D5,  A4,  G4,  G5,  A4, F#5,  A4
000342r 2                               ;.byte       $51, $4A, $48, $58, $4A, $56, $4A
000342r 2  50 49 46 56                  .byte       $50, $49, $46, $56, $49, $55, $49   ; half-note flat
000346r 2  49 55 49     
000349r 2               
000349r 2               SOUND_TEST:
000349r 2                               ; Set basic FM patch (simple sine-like sound)
000349r 2  A2 20                        ldx         #$20
00034Br 2  A9 C7                        lda         #$C7
00034Dr 2  20 rr rr                     jsr         YM_WRITE
000350r 2               
000350r 2  A2 80                        ldx         #$80
000352r 2  A9 1F                        lda         #$1F
000354r 2  20 rr rr                     jsr         YM_WRITE
000357r 2               
000357r 2  A2 E0                        ldx         #$E0
000359r 2  A9 0F                        lda         #$0F
00035Br 2  20 rr rr                     jsr         YM_WRITE
00035Er 2               
00035Er 2  A2 21                        ldx         #$21
000360r 2  A9 C7                        lda         #$C7
000362r 2  20 rr rr                     jsr         YM_WRITE
000365r 2               
000365r 2  A2 81                        ldx         #$81
000367r 2  A9 1F                        lda         #$1F
000369r 2  20 rr rr                     jsr         YM_WRITE
00036Cr 2               
00036Cr 2  A2 E1                        ldx         #$E1
00036Er 2  A9 0F                        lda         #$0F
000370r 2  20 rr rr                     jsr         YM_WRITE
000373r 2               
000373r 2  A9 00                        lda         #$00    ; Channel 0
000375r 2  A2 rr                        ldx         #<GUITAR_PATCH
000377r 2  A0 rr                        ldy         #>GUITAR_PATCH
000379r 2  20 rr rr                     jsr         YM_LOADPATCH
00037Cr 2               
00037Cr 2  A9 01                        lda         #$01    ; Channel 1
00037Er 2  A2 rr                        ldx         #<GUITAR_PATCH
000380r 2  A0 rr                        ldy         #>GUITAR_PATCH
000382r 2  20 rr rr                     jsr         YM_LOADPATCH
000385r 2               
000385r 2  A2 60                        ldx         #$60    ; Total Level (volume) for operator 1, Channel 0
000387r 2  A9 00                        lda         #$00    ; Max Volume
000389r 2  20 rr rr                     jsr         YM_WRITE
00038Cr 2               
00038Cr 2  A2 61                        ldx         #$61    ; Total Level (volume) for operator 1, Channel 1
00038Er 2  A9 00                        lda         #$00    ; Max Volume
000390r 2  20 rr rr                     jsr         YM_WRITE
000393r 2               
000393r 2  A9 rr                        lda         #<SCOM_NOTES_0
000395r 2  85 A0                        sta         YMN0L
000397r 2  A9 rr                        lda         #>SCOM_NOTES_0
000399r 2  85 A1                        sta         YMN0H
00039Br 2               
00039Br 2  A9 rr                        lda         #<SCOM_NOTES_1
00039Dr 2  85 A2                        sta         YMN1L
00039Fr 2  A9 rr                        lda         #>SCOM_NOTES_1
0003A1r 2  85 A3                        sta         YMN1H
0003A3r 2               
0003A3r 2  A0 00                        ldy         #0          ; counter for channel 0
0003A5r 2               @play_loop:
0003A5r 2                               ; 0. set outer counter to 0
0003A5r 2                               ; 1. key off channel 0
0003A5r 2                               ; 1a.  key off on channel 1
0003A5r 2                               ; 2. set note to next note in channel 0 list
0003A5r 2                               ; 3. key on on channel 0
0003A5r 2                               ; 4. one delay
0003A5r 2                               ; 5. notes for rest of sequence on channel 1
0003A5r 2                               ; 5a.  reset counter to 0
0003A5r 2                               ; 5b.  key off on channel 1
0003A5r 2                               ; 5c.  set note on channel 1
0003A5r 2                               ; 5d.  key on on channel 1
0003A5r 2                               ; 5e.  one delay
0003A5r 2                               ; 5f.  increment counter
0003A5r 2                               ; 5g.  loop until 7 notes have been played on channel 1
0003A5r 2                               ; 6.  increment outer counter to play next start note on channel 0
0003A5r 2                               ; 7.  loop back to 1 until outer count reaches 8 (8 sequences have played)
0003A5r 2                               ; Key Off (silence previous note)
0003A5r 2               
0003A5r 2  A2 08                        ldx         #$08    ; Key On/Off register
0003A7r 2  A9 00                        lda         #$00    ; CH0 off
0003A9r 2  20 rr rr                     jsr         YM_WRITE
0003ACr 2               
0003ACr 2  A2 08                        ldx         #$08    ; Key On/Off register
0003AEr 2  A9 01                        lda         #$01    ; CH1 off
0003B0r 2  20 rr rr                     jsr         YM_WRITE
0003B3r 2               
0003B3r 2                               ; Set frequency (KC)
0003B3r 2  A2 28                        ldx         #$28    ; KC register for CH0
0003B5r 2  B1 A0                        lda         (YMN0L),y
0003B7r 2  20 rr rr                     jsr         YM_WRITE
0003BAr 2               
0003BAr 2                               ; Key On
0003BAr 2  A2 08                        ldx         #$08    ; Key On/Off register
0003BCr 2  A9 78                        lda         #$78    ; CH0 on
0003BEr 2  20 rr rr                     jsr         YM_WRITE
0003C1r 2               
0003C1r 2                               ; Delay 8 64th notes in length
0003C1r 2  A9 08                        lda         #8
0003C3r 2  20 rr rr                     jsr         YM_DELAY_64
0003C6r 2               
0003C6r 2  5A                           phy
0003C7r 2  A0 00                        ldy         #0
0003C9r 2  80 07                        bra         @skip_ch1_off   ; already off at the start of the loop
0003CBr 2               
0003CBr 2               @next_ch1:
0003CBr 2  A2 08                        ldx         #$08    ; Key On/Off register
0003CDr 2  A9 01                        lda         #$01    ; CH1 off
0003CFr 2  20 rr rr                     jsr         YM_WRITE
0003D2r 2               
0003D2r 2               @skip_ch1_off:
0003D2r 2                               ; Set frequency (KC)
0003D2r 2  A2 29                        ldx         #$29    ; KC register for CH1
0003D4r 2  B1 A2                        lda         (YMN1L),y
0003D6r 2  20 rr rr                     jsr         YM_WRITE
0003D9r 2               
0003D9r 2                               ; Key On
0003D9r 2  A2 08                        ldx         #$08    ; Key On/Off register
0003DBr 2  A9 79                        lda         #$79    ; CH1 on
0003DDr 2  20 rr rr                     jsr         YM_WRITE
0003E0r 2               
0003E0r 2                               ; Delay 8 64th notes in length
0003E0r 2  A9 08                        lda         #8
0003E2r 2  20 rr rr                     jsr         YM_DELAY_64
0003E5r 2               
0003E5r 2  C8                           iny
0003E6r 2  C0 07                        cpy         #7
0003E8r 2  D0 E1                        bne         @next_ch1
0003EAr 2               
0003EAr 2                               ; Next note on CH0
0003EAr 2  7A                           ply                 ; pull CH0 count
0003EBr 2  C8                           iny
0003ECr 2  C0 08                        cpy         #8      ; 8 bars
0003EEr 2  D0 B5                        bne         @play_loop
0003F0r 2               
0003F0r 2                               ; Stop sound
0003F0r 2  A2 08                        ldx         #$08
0003F2r 2  A9 00                        lda         #$00
0003F4r 2  20 rr rr                     jsr         YM_WRITE
0003F7r 2               
0003F7r 2  A2 08                        ldx         #$08
0003F9r 2  A9 01                        lda         #$01
0003FBr 2  4C rr rr                     jmp         YM_WRITE
0003FEr 2               
0003FEr 2               YM_TIMEOUT = 64
0003FEr 2               
0003FEr 2               ; Write value in A to YM-2151 register in X
0003FEr 2               YM_WRITE:
0003FEr 2  78                           sei
0003FFr 2  5A                           phy
000400r 2  A0 40                        ldy         #YM_TIMEOUT
000402r 2               
000402r 2               @ym_wait1:
000402r 2  88                           dey
000403r 2  30 18                        bmi         @timeout
000405r 2  2C rr rr                     bit         YM_DATA
000408r 2  30 F8                        bmi         @ym_wait1
00040Ar 2  8E rr rr                     stx         YM_REG
00040Dr 2  A0 40                        ldy         #YM_TIMEOUT
00040Fr 2               
00040Fr 2               @ym_wait2:
00040Fr 2  88                           dey
000410r 2  30 0B                        bmi         @timeout
000412r 2  2C rr rr                     bit         YM_DATA
000415r 2  30 F8                        bmi         @ym_wait2
000417r 2  8D rr rr                     sta         YM_DATA
00041Ar 2  18                           clc
00041Br 2  80 01                        bra         @cleanup
00041Dr 2               
00041Dr 2               @timeout:
00041Dr 2  38                           sec
00041Er 2               
00041Er 2               @cleanup:
00041Er 2  7A                           ply
00041Fr 2  58                           cli
000420r 2  60                           rts
000421r 2               
000421r 2               YM_LOADPATCH:
000421r 2                               ; Make re-entrant safe by protecting tmp and pointer variables from interrupt
000421r 2  08                           php
000422r 2  78                           sei
000423r 2               
000423r 2                               ; and #$07 ; mask channel to range 0..7
000423r 2  86 B0                        stx AZP0L
000425r 2  84 B1                        sty AZP0H
000427r 2  18                           clc
000428r 2  69 20                        adc #$20 ; first byte of patch goes to YM:$20+channel
00042Ar 2  AA                           tax
00042Br 2               
00042Br 2  B2 B0                        lda (AZP0L)
00042Dr 2  29 3F                        and #$3F
00042Fr 2               
00042Fr 2                               ;sta ymtmp1
00042Fr 2                               ;lda ymshadow,x
00042Fr 2                               ;and #$C0 ; L+R bits for YM channel
00042Fr 2                               ;ora ymtmp1 ; Add the patch byte without L+R
00042Fr 2  09 C0                        ora #$C0;
000431r 2               
000431r 2  20 rr rr                     jsr YM_WRITE
000434r 2  B0 16                        bcs @fail
000436r 2  A0 00                        ldy #0
000438r 2  8A                           txa      ; YM_WRITE preserves X (YM register)
000439r 2                               ; Now skip over $28 and $30 by adding $10 to the register address.
000439r 2                               ; C guaranteed clear by successful ym_write
000439r 2  69 10                        adc #$10
00043Br 2  AA                           tax      ; set up for loop
00043Cr 2               @next:
00043Cr 2  8A                           txa
00043Dr 2                               ; C guaranteed clear by successful YM_WRITE
00043Dr 2  69 08                        adc #$08
00043Fr 2  B0 0E                        bcs @success
000441r 2  C8                           iny
000442r 2  AA                           tax
000443r 2  B1 B0                        lda (AZP0L),y
000445r 2  5A                           phy      ; YM_WRITE clobbers .Y
000446r 2  20 rr rr                     jsr YM_WRITE
000449r 2  7A                           ply
00044Ar 2  90 F0                        bcc @next
00044Cr 2               @fail:
00044Cr 2  28                           plp ; restore interrupt flag
00044Dr 2  38                           sec
00044Er 2  60                           rts      ; return C set as failed patch write.
00044Fr 2               @success:
00044Fr 2  28                           plp ; restore interrupt flag
000450r 2  18                           clc
000451r 2  60                           rts
000452r 2               
000452r 2               ; YM_DELAY_64 - Delay subroutine for musical note lengths
000452r 2               ; A: number of 64th-note delays to wait (a 64th note @120 BPM = ~ 111,861 clock cycles @ 3.57955 MHz)
000452r 2               YM_DELAY_64:
000452r 2  DA 5A                        PUSH_XY
000454r 2  85 B2                        sta         YMTMP1
000456r 2               
000456r 2               @far_outer:
000456r 2  A9 01                        lda         #1          ; 2 cycles
000458r 2  A2 4B                        ldx         #75
00045Ar 2  A0 8E                        ldy         #142
00045Cr 2  80 04                        bra         @inner
00045Er 2               
00045Er 2               @outer:
00045Er 2  A2 00                        ldx         #0          ; 2 cycles
000460r 2               
000460r 2               @mid:
000460r 2  A0 00                        ldy         #0          ; 2 cycles
000462r 2               
000462r 2               @inner:
000462r 2  88                           dey                     ; 2 cycles
000463r 2  D0 FD                        bne         @inner      ; 3 cycles when branching, 2 when not
000465r 2  CA                           dex                     ; 2 cycles
000466r 2  D0 F8                        bne         @mid        ; 3 cycles when branching, 2 when not
000468r 2               
000468r 2                               ; Fine-tuning at end of inner loop
000468r 2  3A                           dec                     ; 2 cycles
000469r 2  D0 F3                        bne         @outer      ; 3 cycles when branching, 2 when not
00046Br 2  C6 B2                        dec         YMTMP1      ; 3 cycles
00046Dr 2  D0 E7                        bne         @far_outer  ; 3 cycles when branching, 2 when not
00046Fr 2  7A FA                        PULL_YX
000471r 2  60                           rts                     ; 6 cycles
000472r 2               
000472r 1               .include "wozmon.s"
000472r 2               .segment "WOZMON"
000000r 2               
000000r 2               XAML            = ZP_LAST_USED + 1      ; Last "opened" location Low
000000r 2               XAMH            = XAML + 1              ; Last "opened" location High
000000r 2               STL             = XAML + 2              ; Store address Low
000000r 2               STH             = XAML + 3              ; Store address High
000000r 2               L               = XAML + 4              ; Hex value parsing Low
000000r 2               H               = XAML + 5              ; Hex value parsing High
000000r 2               MODE            = XAML + 6              ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
000000r 2               
000000r 2               IN              = $7E00
000000r 2               
000000r 2               ; WOZMON Entrypoint
000000r 2               MON_START:
000000r 2  D8                           cld                     ; Clear decimal arithmetic mode.
000001r 2  58                           cli                     ; Enable interrupts
000002r 2  80 10                        bra    @is_start
000004r 2               
000004r 2               @not_cr:
000004r 2  C9 08                        cmp     #ASCII_BACKSPACE
000006r 2  F0 14                        beq     @is_backspace
000008r 2  C9 1B                        cmp     #ASCII_ESC
00000Ar 2  F0 03                        beq     @is_escape
00000Cr 2  C8                           iny                     ; Advance text index.
00000Dr 2  10 10                        bpl     @get_next_char  ; Auto ESC if line longer than 127.
00000Fr 2               
00000Fr 2               @is_escape:
00000Fr 2  A9 5C 20 rr                  PRINT_CHAR      #ASCII_BACKSLASH
000013r 2  rr           
000014r 2               @is_start:
000014r 2  20 rr rr                     PRINT_CRLF
000017r 2               
000017r 2               @get_line:
000017r 2  20 rr rr                     jsr     WRITE_PROMPT
00001Ar 2  A0 01                        ldy     #1              ; Initialize text index.
00001Cr 2               
00001Cr 2               @is_backspace:
00001Cr 2  88                           dey                     ; Back up text index.
00001Dr 2  30 F8                        bmi     @get_line       ; Beyond start of line, reinitialize.
00001Fr 2               
00001Fr 2               @get_next_char:
00001Fr 2  20 rr rr                     jsr     READ_CHAR
000022r 2  90 FB                        bcc     @get_next_char
000024r 2  99 00 7E                     sta     IN,y            ; Add to text buffer.
000027r 2  C9 0D                        cmp     #ASCII_CR
000029r 2  D0 D9                        bne     @not_cr
00002Br 2  A0 FF                        ldy     #$FF            ; Reset text index.  Will iny shortly...
00002Dr 2  A9 00                        lda     #$00            ; For XAM mode.
00002Fr 2  AA                           tax                     ; X=0.
000030r 2               
000030r 2               @set_block:
000030r 2  0A                           asl
000031r 2               
000031r 2               @set_store:
000031r 2  0A                           asl                     ; Leaves $7B if setting STOR mode.
000032r 2               
000032r 2               @set_mode:
000032r 2  85 25                        sta     MODE            ; $00 = XAM, $74 = STOR, $B8 = BLOK XAM.
000034r 2               
000034r 2               @skip_delim:
000034r 2  C8                           iny                     ; Advance text index.
000035r 2               
000035r 2               @next_item:
000035r 2  B9 00 7E                     lda     IN,y            ; Get character.
000038r 2  C9 0D                        cmp     #ASCII_CR       ; CR?
00003Ar 2  F0 DB                        beq     @get_line       ; Yes, done this line.
00003Cr 2  C9 2E                        cmp     #ASCII_PERIOD
00003Er 2  90 F4                        bcc     @skip_delim     ; Skip delimiter.
000040r 2  F0 EE                        beq     @set_block      ; Set BLOCK XAM mode.
000042r 2  C9 3A                        cmp     #ASCII_COLON
000044r 2  F0 EB                        beq     @set_store      ; Yes, set STOR mode.
000046r 2  C9 52                        cmp     #ASCII_R
000048r 2  F0 4E                        beq     @run_prog       ; Yes, run user program
00004Ar 2  C9 54                        cmp     #ASCII_T        ; T, U, V, or W registers?
00004Cr 2  90 0F                        bcc     @not_tuvw       ;
00004Er 2  C9 58                        cmp     #ASCII_X        ;
000050r 2  B0 0B                        bcs     @not_tuvw       ;
000052r 2  69 9C                        adc     #($F0-ASCII_T)  ; T=FFF0, U=FFF1, V=FFF2, W=FFF3
000054r 2  85 23                        sta     L               ;
000056r 2  A9 FF                        lda     #$FF            ;
000058r 2  85 24                        sta     H               ;
00005Ar 2  C8                           iny                     ; skip the mnemonic
00005Br 2  80 2A                        bra     @not_hex_or_escape
00005Dr 2               
00005Dr 2               @not_tuvw:
00005Dr 2  84 1A                        sty     ZP_Y_SAVE       ; Save Y for comparison
00005Fr 2  86 23                        stx     L               ; $00 -> L
000061r 2  86 24                        stx     H               ; ...and H.
000063r 2               
000063r 2               @next_hex:
000063r 2  B9 00 7E                     lda     IN,y            ; Get character for hex test.
000066r 2  49 30                        eor     #ASCII_0        ; Map digits to $0-9.
000068r 2  C9 0A                        cmp     #10             ; Digit?
00006Ar 2  90 06                        bcc     @is_digit       ; Yes.
00006Cr 2  69 88                        adc     #$88            ; Map letter "A"-"F" to $FA-FF.
00006Er 2  C9 FA                        cmp     #$FA            ; Hex letter?
000070r 2  90 11                        bcc     @not_hex        ; No, character not hex.
000072r 2               
000072r 2               @is_digit:
000072r 2  0A                           asl                     ; LSD to MSD of A.
000073r 2  0A                           asl
000074r 2  0A                           asl
000075r 2  0A                           asl
000076r 2  A2 04                        ldx     #4              ; Shift count.
000078r 2               
000078r 2               @hex_shift:
000078r 2  0A                           asl                     ; Hex digit left, MSB to carry.
000079r 2  26 23                        rol     L               ; Rotate into LSD.
00007Br 2  26 24                        rol     H               ; Rotate into MSD's.
00007Dr 2  CA                           dex                     ; Done 4 shifts?
00007Er 2  D0 F8                        bne     @hex_shift      ; No, loop.
000080r 2  C8                           iny                     ; Advance text index.
000081r 2  D0 E0                        bne     @next_hex       ; Always taken. Check next character for hex.
000083r 2               
000083r 2               @not_hex:
000083r 2  C4 1A                        cpy     ZP_Y_SAVE       ; Check if L, H empty (no hex digits).
000085r 2  F0 88                        beq     @is_escape      ; Yes, generate ESC sequence.
000087r 2               
000087r 2               @not_hex_or_escape:
000087r 2  24 25                        bit     MODE            ; Test MODE byte.
000089r 2  50 16                        bvc     @not_store      ; B6=0 is STOR, 1 is XAM and BLOCK XAM.
00008Br 2  A5 23                        lda     L               ; LSD's of hex data.
00008Dr 2  92 21                        sta     (STL)           ; Store current 'store index'.
00008Fr 2  E6 21                        inc     STL             ; Increment store index.
000091r 2  D0 A2                        bne     @next_item      ; Get next item (no carry).
000093r 2  E6 22                        inc     STH             ; Add carry to 'store index' high order.
000095r 2               
000095r 2               @to_next_item:
000095r 2  4C rr rr                     jmp     @next_item      ; Get next command item.
000098r 2               
000098r 2               @run_prog:
000098r 2  A9 rr 48 A9                  JSRR    XAML, MON_START
00009Cr 2  rr 48 6C 1F  
0000A0r 2  00           
0000A1r 2               
0000A1r 2               @not_store:
0000A1r 2  30 29                        bmi     @examine_next   ; B7 = 0 for XAM, 1 for BLOCK XAM.
0000A3r 2  A2 02                        ldx     #2              ; Byte count.
0000A5r 2               
0000A5r 2               @set_addr:
0000A5r 2  B5 22                        lda     L-1,x           ; Copy hex data to
0000A7r 2  95 20                        sta     STL-1,x         ;  'store index'.
0000A9r 2  95 1E                        sta     XAML-1,x        ; And to 'XAM index'.
0000ABr 2  CA                           dex                     ; Next of 2 bytes.
0000ACr 2  D0 F7                        bne     @set_addr       ; Loop unless X = 0.
0000AEr 2               
0000AEr 2               @print_next:
0000AEr 2  D0 12                        bne     @print_data     ; NE means no address to print.
0000B0r 2  20 rr rr                     PRINT_CRLF
0000B3r 2  A5 20 20 rr                  PRINT_BYTE  XAMH        ; Print 'Examine index' high-order byte.
0000B7r 2  rr           
0000B8r 2  A5 1F 20 rr                  PRINT_BYTE  XAML        ; Print 'Examine index' low-order byte.
0000BCr 2  rr           
0000BDr 2  A9 3A 20 rr                  PRINT_CHAR  #ASCII_COLON; Print a ':'.
0000C1r 2  rr           
0000C2r 2               
0000C2r 2               @print_data:
0000C2r 2  A9 20 20 rr                  PRINT_CHAR  #ASCII_SPACE; Print a ' '.
0000C6r 2  rr           
0000C7r 2  A1 1F 20 rr                  PRINT_BYTE  {(XAML,x)}  ; Print the byte at 'examine index'.
0000CBr 2  rr           
0000CCr 2               
0000CCr 2               @examine_next:
0000CCr 2  86 25                        stx     MODE            ; 0 -> MODE (XAM mode).
0000CEr 2  A5 1F                        lda     XAML
0000D0r 2  C5 23                        cmp     L               ; Compare 'examine index' to hex data.
0000D2r 2  A5 20                        lda     XAMH
0000D4r 2  E5 24                        sbc     H
0000D6r 2  B0 BD                        bcs     @to_next_item   ; Not less, so no more data to output.
0000D8r 2  E6 1F                        inc     XAML
0000DAr 2  D0 02                        bne     @mod_8_check    ; Increment 'examine index'.
0000DCr 2  E6 20                        inc     XAMH
0000DEr 2               
0000DEr 2               @mod_8_check:
0000DEr 2  A5 1F                        lda     XAML            ; Check low-order 'examine index' byte
0000E0r 2  29 07                        and     #7              ; For MOD 8 = 0
0000E2r 2  10 CA                        bpl     @print_next     ; Always taken.
0000E4r 2               
0000E4r 1               .include "mmu.s"
0000E4r 2               .debuginfo
0000E4r 2               .segment "MMU"
000000r 2               
000000r 2               MMU_INIT:
000000r 2  60                       rts
000001r 2               
000001r 2               MEM_TEST:
000001r 2  48 DA                    PUSH_AX
000003r 2  20 rr rr                 PRINT_CRLF
000006r 2  9C 00 00                 stz         RAM_BANK_REG
000009r 2  9C F0 FF                 stz         T_REGISTER
00000Cr 2               
00000Cr 2               @task_num_loop:
00000Cr 2  A9 02                    lda         #$02
00000Er 2  A2 7D                    ldx         #$7D                ; exclude the task serial buffers @ $7E00 && $7F00
000010r 2  20 rr rr                 jsr         TEST_PAGE_RANGE
000013r 2  A2 A0                    ldx         #$A0                ; end of banked RAM
000015r 2               
000015r 2               @ram_bank_loop:
000015r 2  AD 00 00 20              PRINT_BYTE  RAM_BANK_REG
000019r 2  rr rr        
00001Br 2  A9 2E 20 rr              PRINT_CHAR  #ASCII_PERIOD
00001Fr 2  rr           
000020r 2  A9 80                    lda         #$80
000022r 2  20 rr rr                 jsr         TEST_PAGE_RANGE
000025r 2  EE 00 00                 inc         RAM_BANK_REG
000028r 2  A9 F0                    lda         #NUM_RAM_BANKS
00002Ar 2  CD 00 00                 cmp         RAM_BANK_REG
00002Dr 2  D0 E6                    bne         @ram_bank_loop
00002Fr 2                           ;inc        T_REGISTER
00002Fr 2                           ;lda        #$10
00002Fr 2                           ;cmp        T_REGISTER
00002Fr 2                           ;bne         @task_num_loop
00002Fr 2  9C F1 FF                 stz         U_REGISTER
000032r 2               
000032r 2               @shared_banks_loop:
000032r 2  A9 F0                    lda         #$F0
000034r 2  8D 00 00                 sta         RAM_BANK_REG
000037r 2               
000037r 2               @shared_bank_loop:
000037r 2  AD F1 FF 20              PRINT_BYTE  U_REGISTER
00003Br 2  rr rr        
00003Dr 2  A9 2E 20 rr              PRINT_CHAR  #ASCII_PERIOD
000041r 2  rr           
000042r 2  AD 00 00 20              PRINT_BYTE  RAM_BANK_REG
000046r 2  rr rr        
000048r 2  A9 2E 20 rr              PRINT_CHAR  #ASCII_PERIOD
00004Cr 2  rr           
00004Dr 2  A9 80                    lda         #$80
00004Fr 2  20 rr rr                 jsr         TEST_PAGE_RANGE
000052r 2  EE 00 00                 inc         RAM_BANK_REG        ; increment shared bank
000055r 2  D0 E0                    bne         @shared_bank_loop
000057r 2  EE F1 FF                 inc         U_REGISTER
00005Ar 2  AD F1 FF                 lda         U_REGISTER
00005Dr 2  C9 10                    cmp         #$10
00005Fr 2  90 D1                    bcc         @shared_banks_loop
000061r 2  FA 68                    PULL_XA
000063r 2  60                       rts
000064r 2               
000064r 2               ; Pass HOB of first page to test in A, HOB of last page + 1 in X
000064r 2               TEST_PAGE_RANGE:
000064r 2  85 17                    sta         ZP_TEMP_VEC_H
000066r 2  20 rr rr                 PRINT_BYTE
000069r 2  A9 00 20 rr              PRINT_BYTE  #0
00006Dr 2  rr           
00006Er 2  A9 2E 20 rr              PRINT_CHAR  #ASCII_PERIOD
000072r 2  rr           
000073r 2  8A                       txa
000074r 2  18                       clc
000075r 2  E9 00                    sbc         #0
000077r 2  20 rr rr                 PRINT_BYTE
00007Ar 2  A9 FF 20 rr              PRINT_BYTE  #$FF
00007Er 2  rr           
00007Fr 2  A9 3A 20 rr              PRINT_CHAR  #ASCII_COLON
000083r 2  rr           
000084r 2  20 rr rr                 PRINT_CRLF
000087r 2  64 16                    stz         ZP_TEMP_VEC_L
000089r 2  64 12                    stz         ZP_TEMP
00008Br 2               
00008Br 2               @loop_init:
00008Br 2  A9 EA                    lda         #$EA                ; NOP test pattern
00008Dr 2               
00008Dr 2               @loop:
00008Dr 2  92 16                    sta         (ZP_TEMP_VEC_L)
00008Fr 2  D2 16                    cmp         (ZP_TEMP_VEC_L)
000091r 2  F0 04                    beq         @next
000093r 2  A9 21                    lda         #ASCII_BANG
000095r 2  80 06                    bra         @write
000097r 2               
000097r 2               @next:
000097r 2  E6 16                    inc         ZP_TEMP_VEC_L
000099r 2  D0 F2                    bne         @loop
00009Br 2  A9 2E                    lda         #ASCII_PERIOD
00009Dr 2               
00009Dr 2               @write:
00009Dr 2  20 rr rr                 jsr         WRITE_CHAR
0000A0r 2  64 12                    stz         ZP_TEMP
0000A2r 2  E6 17                    inc         ZP_TEMP_VEC_H
0000A4r 2  E4 17                    cpx         ZP_TEMP_VEC_H
0000A6r 2  D0 E3                    bne         @loop_init
0000A8r 2  4C rr rr                 PRINT_CRLF_JMP
0000ABr 2               
0000ABr 1               .include "tasks.s"
0000ABr 2               .debuginfo
0000ABr 2               .segment "TASKS"
000000r 2               
000000r 2               TASK_0_VECTOR           = $E000
000000r 2               RAM_BANK_REG            = $00
000000r 2               ROM_BANK_REG            = $01
000000r 2               TASK_STATUS_REG         = $02
000000r 2               TASK_PARENT             = $03
000000r 2               STACK_SAVE_REG          = $04
000000r 2               
000000r 2               TASK_BUSY_FLAG          = $01
000000r 2               TASK_PAUSED_FLAG        = $02
000000r 2               
000000r 2               ; TASK STATUS REGISTER BITS
000000r 2               ;   0: 0 = Available, 1 = In Use
000000r 2               
000000r 2               .macro SELECT_TASK      task
000000r 2                               lda     T_REGISTER
000000r 2                               and     #$F0
000000r 2                               ora     task & $0F
000000r 2                               sta     T_REGISTER
000000r 2               .endmacro
000000r 2               
000000r 2               .macro SELECT_SHARED_BANK bank
000000r 2                               lda     T_REGISTER
000000r 2                               and     #$0F
000000r 2                               ora     bank << 4
000000r 2                               sta     T_REGISTER
000000r 2               .endmacro
000000r 2               
000000r 2               ; Initialize the tasks, their stacks, etc.
000000r 2               TASKS_INIT:
000000r 2  78                       sei                                     ; Turn off interrupts
000001r 2  AD F0 FF                 lda     T_REGISTER
000004r 2  D0 1A                    bne     @cleanup                        ; Only support task init when on task 0
000006r 2  A2 0F                    ldx     #MAX_TASK_NUMBER
000008r 2               
000008r 2               @loop:
000008r 2  A9 00                    lda     #0
00000Ar 2  8E F0 FF                 stx     T_REGISTER                      ; Quick switch to task X
00000Dr 2  85 00                    sta     RAM_BANK_REG
00000Fr 2  85 01                    sta     ROM_BANK_REG
000011r 2  85 02                    sta     TASK_STATUS_REG
000013r 2  85 03                    sta     TASK_PARENT
000015r 2  A9 FF                    lda     #$FF
000017r 2  85 04                    sta     STACK_SAVE_REG
000019r 2  A5 10 85 11              MOV     ZP_READ_PTR, ZP_WRITE_PTR       ; Do INIT_BUFFER, without the stack
00001Dr 2  CA                       dex
00001Er 2  10 E8                    bpl     @loop                           ; Loop back as long as X >= 0
000020r 2               
000020r 2                           ; setup interrupt handler and interrupt timer
000020r 2               
000020r 2                           ; Will fall through when X = $FF, leaving us in Task 0, as required
000020r 2               
000020r 2               @cleanup:
000020r 2  58                       cli                                     ; Turn interrupts back on
000021r 2  60                       rts
000022r 2               
000022r 2               ;  Task switch
000022r 2               ;  Task# to switch to in A
000022r 2               SWITCH_TO:
000022r 2  68                       pla                                     ; need to change return addr from RTS style (IP - 1) to RTI style (IP)
000023r 2  1A                       inc
000024r 2  48                       pha
000025r 2  08                       php
000026r 2               
000026r 2               SWITCH_TO_NO_PHP:
000026r 2  48 DA 5A                 PUSH_AXY
000029r 2  9A                       txs
00002Ar 2  86 04                    stx     STACK_SAVE_REG
00002Cr 2               
00002Cr 2               SWITCH_TO_NSS:
00002Cr 2  8D F0 FF                 sta     T_REGISTER
00002Fr 2  A6 04                    ldx     STACK_SAVE_REG                  ; Restore the stack pointer
000031r 2  9A                       txs                                     ; ...
000032r 2  7A FA 68                 PULL_YXA
000035r 2  40                       rti
000036r 2               
000036r 2               ; Find a task that is idle and start it executing at the address in ZP_TEMP_VEC_L && ZP_TEMP_VEC_H
000036r 2               ; Return task # in A and C == 1
000036r 2               ;   OR error in A and C == 0 (if no task available)
000036r 2               TASK_START:
000036r 2  20 rr rr                 jsr     RESERVE_TASK
000039r 2  B0 03                    bcs     @start_task
00003Br 2  A9 F1                    lda     #ERR_NO_TASKS_AVAILABLE
00003Dr 2  60                       rts
00003Er 2               
00003Er 2               @start_task:
00003Er 2  A8                       tay
00003Fr 2  AD F0 FF                 lda     T_REGISTER                      ; save current task as new task's parent
000042r 2  8C F0 FF                 sty     T_REGISTER
000045r 2  85 03                    sta     TASK_PARENT
000047r 2  8D F0 FF                 sta     T_REGISTER                      ; get the new task start addr in A/X
00004Ar 2  A5 16                    lda     ZP_TEMP_VEC_L
00004Cr 2  A6 17                    ldx     ZP_TEMP_VEC_H
00004Er 2  8C F0 FF                 sty     T_REGISTER                      ; do the task switch
000051r 2  86 19                    stx     ZP_X_SAVE                       ; new task ZP
000053r 2  A2 FF                    ldx     #$FF                            ; Reset the stack pointer
000055r 2  9A                       txs
000056r 2  A6 19                    ldx     ZP_X_SAVE
000058r 2  20 rr rr                 jsr     @task_start
00005Br 2               
00005Br 2               @task_complete:
00005Br 2  A9 01                    lda     #TASK_BUSY_FLAG
00005Dr 2  14 02                    trb     TASK_STATUS_REG
00005Fr 2  A2 FF                    ldx     #$FF
000061r 2  86 03                    stx     TASK_PARENT                     ; ...and reset the resume-to register to #$FF (invalid)
000063r 2  20 rr rr                 jsr     NEXT_TASK
000066r 2  4C rr rr                 jmp     SWITCH_TO_NSS
000069r 2               
000069r 2               @task_start:
000069r 2  DA                       phx                                     ; push the start address onto the stack
00006Ar 2  48                       pha                                     ; ...
00006Br 2  60                       rts                                     ; start executing
00006Cr 2               
00006Cr 2               
00006Cr 2               ; Find an available task
00006Cr 2               ; Modifies: A, CNZ Flags
00006Cr 2               ; Returns C = 1 AND A = TaskNumber (when found)
00006Cr 2               ; Returns C = 0 AND A = $FF        (when not found)
00006Cr 2               RESERVE_TASK:
00006Cr 2  78                       sei                                     ; Disable interrupts
00006Dr 2  DA 5A                    PUSH_XY
00006Fr 2               
00006Fr 2               ; !! NO STACK MANIPULATIONS UNTIL SWITCHING BACK TO ORIGINAL TASK !!
00006Fr 2  A9 00                    lda     #0
000071r 2  AC F0 FF                 ldy     T_REGISTER
000074r 2  A9 01                    lda     #TASK_BUSY_FLAG
000076r 2  A2 0F                    ldx     #$F                             ; Start search with Task $F
000078r 2               
000078r 2               @task_busy:
000078r 2  8E F0 FF                 stx     T_REGISTER                      ; Quick task switch to task X
00007Br 2  24 02                    bit     TASK_STATUS_REG                 ; Is Bit 1 set?
00007Dr 2  D0 07                    bne     @task_found
00007Fr 2  CA                       dex                                     ; Not found, so DEC X
000080r 2  D0 F6                    bne     @task_busy                      ; Until X is zero, loop
000082r 2  18                       clc                                     ; Not found
000083r 2  CA                       dex                                     ; X == $FF
000084r 2  90 05                    bcc     @cleanup
000086r 2               
000086r 2               @task_found:
000086r 2  A9 03                    lda     #TASK_BUSY_FLAG|TASK_PAUSED_FLAG
000088r 2  85 02                    sta     TASK_STATUS_REG                 ; SET the Task as Busy and Paused
00008Ar 2  38                       sec                                     ; Found
00008Br 2               
00008Br 2               @cleanup:
00008Br 2  8A                       txa                                     ; Return the task number in A (OR $FF if not found)
00008Cr 2  8C F0 FF                 sty     T_REGISTER                      ; Switch back to the original task
00008Fr 2               
00008Fr 2               ; Back on the original task, so restore the registers
00008Fr 2  7A FA                    PULL_YX
000091r 2  58                       cli                                     ; Re-enable interrupts
000092r 2  60                       rts
000093r 2               
000093r 2               ; Find the next task that is paused
000093r 2               ; Return task # to switch to in A.  C == 0, none found; C == 1, found
000093r 2               NEXT_TASK:
000093r 2  48 DA                    PUSH_AX
000095r 2  AD F0 FF                 lda     T_REGISTER
000098r 2  85 19                    sta     ZP_X_SAVE
00009Ar 2  29 0F                    and     #$0F                            ; mask off the shared memory "bank of banks"
00009Cr 2  85 18                    sta     ZP_A_SAVE
00009Er 2  AA                       tax
00009Fr 2               
00009Fr 2               @test_next:
00009Fr 2  E8                       inx
0000A0r 2  8A                       txa
0000A1r 2  29 0F                    and     #$0F                            ; masking again since we could have carried
0000A3r 2  C5 18                    cmp     ZP_A_SAVE                       ; are we back where we started?
0000A5r 2  F0 0C                    beq     @not_found
0000A7r 2  8D F0 FF                 sta     T_REGISTER                      ; switch to the next task
0000AAr 2  A9 02                    lda     #TASK_PAUSED_FLAG
0000ACr 2  25 02                    and     TASK_STATUS_REG                 ; is this task paused?
0000AEr 2  F0 EF                    beq     @test_next                      ; no? try the next one
0000B0r 2  38                       sec
0000B1r 2  B0 01                    bcs     @done
0000B3r 2               
0000B3r 2               @not_found:
0000B3r 2  18                       clc
0000B4r 2               
0000B4r 2               @done:
0000B4r 2  A6 19                    ldx     ZP_X_SAVE                       ; switch back to the original task
0000B6r 2  8E F0 FF                 stx     T_REGISTER
0000B9r 2  FA 68                    PULL_XA
0000BBr 2  60                       rts
0000BCr 2               
0000BCr 2               ; Non-maskable interrupt handler (same as maskable interrupt handler for now)
0000BCr 2               NMI_HANDLER:
0000BCr 2  48                       pha
0000BDr 2  A9 2A                    lda     #ASCII_STAR
0000BFr 2  20 rr rr                 jsr     WRITE_CHAR
0000C2r 2  68                       pla
0000C3r 2  20 rr rr                 jsr     NEXT_TASK
0000C6r 2  B0 01                    bcs     @switch
0000C8r 2  40                       rti
0000C9r 2               
0000C9r 2               @switch:
0000C9r 2  4C rr rr                 jmp SWITCH_TO_NO_PHP
0000CCr 2               
0000CCr 1               .include "shell.s"
0000CCr 2               .debuginfo
0000CCr 2               .segment "SHELL"
000000r 2               
000000r 2               SHELL_MAIN:
000000r 2  20 rr rr                 jsr     MON_START
000003r 2               
000003r 2               .segment "STACK"
000000r 2               
000000r 1               
000000r 1               .macro W_SAVE_AND_RESET
000000r 1                           sta     ZP_A_SAVE
000000r 1                           lda     W_REGISTER
000000r 1                           sta     ZP_W_SAVE
000000r 1                           stz     W_REGISTER
000000r 1                           lda     ZP_A_SAVE
000000r 1               .endmacro
000000r 1               
000000r 1               .macro W_RESTORE
000000r 1                           sta     ZP_A_SAVE
000000r 1                           lda     ZP_W_SAVE
000000r 1                           sta     W_REGISTER
000000r 1                           lda     ZP_A_SAVE
000000r 1               .endmacro
000000r 1               
000000r 1               .segment "BIOS_P0"
000000r 1               
000000r 1               RESET_ENTRY:
000000r 1  85 18 AD F3              W_SAVE_AND_RESET                            ; Effectively a NOP, since we wouldn't be here if it was non-zero
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1                                                                       ;   but kept for consistency across all OS ROM pages
00000Cr 1  9C F0 FF                 stz     T_REGISTER                          ; Make sure task 0 is selected
00000Fr 1  64 00                    stz     $00                                 ; Init RAM Bank selector
000011r 1  64 01                    stz     $01                                 ; Init ROM Bank selector
000013r 1  A2 FF                    ldx     #$FF                                ; Init stack pointer
000015r 1  9A                       txs
000016r 1                           ; MOV     ZP_READ_PTR, ZP_WRITE_PTR                 ; remove when tasks_init is used
000016r 1               
000016r 1  20 rr rr                 jsr     IRQ_VECTOR_INIT
000019r 1  20 rr rr                 jsr     TASKS_INIT                          ; Must be called before SERIAL_INIT
00001Cr 1  20 rr rr                 jsr     SERIAL_INIT
00001Fr 1                           ;jsr     MMU_INIT
00001Fr 1                           ;jsr     SPI_INIT
00001Fr 1                           ;jsr     SPI_TEST
00001Fr 1  20 rr rr                 jsr     SOUND_INIT
000022r 1  20 rr rr                 jsr     SOUND_TEST
000025r 1  20 rr rr                 jsr     DO_WELCOME
000028r 1  4C rr rr                 jmp     SHELL_MAIN
00002Br 1               
00002Br 1               DO_WELCOME:
00002Br 1  DA                       phx
00002Cr 1  20 rr rr                 jsr     CLEAR_SCR
00002Fr 1  A6 00                    ldx     0
000031r 1  BD rr rr                 lda     HYDRA_WELCOME, X
000034r 1  A8                       tay
000035r 1               @write_loop:
000035r 1  E8                       inx
000036r 1  BD rr rr                 lda     HYDRA_WELCOME, X
000039r 1  20 rr rr                 jsr     WRITE_CHAR
00003Cr 1  88                       dey
00003Dr 1  D0 F6                    bne     @write_loop
00003Fr 1  FA                       plx
000040r 1  20 rr rr                 PRINT_CRLF
000043r 1  A2 00                    ldx     #0
000045r 1               
000045r 1               @vector_loop:
000045r 1  8E F2 FF                 stx         V_REGISTER
000048r 1  DA                       phx
000049r 1  AD F2 FF 20              PRINT_HEX   V_REGISTER
00004Dr 1  rr rr        
00004Fr 1  A9 08 20 rr              PRINT_CHAR  #ASCII_BACKSPACE
000053r 1  rr           
000054r 1  AD F2 FF                 lda         V_REGISTER
000057r 1  20 rr rr                 PRINT_HEX
00005Ar 1  A9 3A 20 rr              PRINT_CHAR  #ASCII_COLON
00005Er 1  rr           
00005Fr 1  AD FF FF 20              PRINT_BYTE  $FFFF
000063r 1  rr rr        
000065r 1  AD FE FF 20              PRINT_BYTE  $FFFE
000069r 1  rr rr        
00006Br 1  A9 20 20 rr              PRINT_CHAR  #ASCII_SPACE
00006Fr 1  rr           
000070r 1  FA                       plx
000071r 1  E8                       inx
000072r 1  E0 10                    cpx         #$10
000074r 1  90 CF                    bcc         @vector_loop
000076r 1  4C rr rr                 PRINT_CRLF_JMP
000079r 1               
000079r 1               SPI_TEST:
000079r 1  A2 00                    ldx         #SPI_DEV_0
00007Br 1  20 rr rr                 jsr         SPI_INIT_DELAY
00007Er 1  A9 40 20 rr              SPI_SEND_CMD 0,    0, 0, 0,   0, $4A        ; CMD0
000082r 1  rr A9 00 20  
000086r 1  rr rr 85 13  
0000A3r 1  A9 48 20 rr              SPI_SEND_CMD 8,    0, 0, 1, $AA, $43        ; CMD8
0000A7r 1  rr A9 00 20  
0000ABr 1  rr rr 85 13  
0000C8r 1               @loop:
0000C8r 1  A9 7A 20 rr              SPI_SEND_CMD 58,   0, 0, 0,   0             ; CMD58
0000CCr 1  rr A9 00 20  
0000D0r 1  rr rr 85 13  
0000EDr 1  A9 69 20 rr              SPI_SEND_CMD 41, $40, 0, 0,   0             ; ACMD41
0000F1r 1  rr A9 40 20  
0000F5r 1  rr rr 85 13  
000112r 1  D0 B4                    bne         @loop
000114r 1  60                       rts
000115r 1               
000115r 1               ; A: S/W interrupt number
000115r 1               SW_INT:
000115r 1  0A                       asl                                         ; move int# to V[4..7]
000116r 1  0A                       asl
000117r 1  0A                       asl
000118r 1  0A                       asl
000119r 1  09 0F                    ora         #$F
00011Br 1  8D F2 FF                 sta         V_REGISTER
00011Er 1  00                       brk                                         ; force an interrupt
00011Fr 1  60                       rts
000120r 1               
000120r 1               .segment "BIOS_P1"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P2"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P3"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P4"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P5"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P6"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P7"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P8"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_P9"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_PA"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_PB"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_PC"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_PD"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_PE"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               .segment "BIOS_PF"
000000r 1  85 18 AD F3              W_SAVE_AND_RESET
000004r 1  FF 85 1E 9C  
000008r 1  F3 FF A5 18  
00000Cr 1               
00000Cr 1               
